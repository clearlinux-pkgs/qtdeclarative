Albert Astals Cid (5):
      Give a warning when StyledText encounters a non supported entity
      Document that StyledText also supports &nbsp; and &quot;
      Support &apos; in styled text
      Remove unused QPointer<QQuickPointerMask>
      Revert "Fix TapHandler so that it actually registers a tap"

Aleix Pol (2):
      QQuickLoader: Do not incubate if the source arrives after setActive(false)
      QQmlDelegateModel: Refresh the view when a column is added at 0

Alessandro Portale (1):
      qmltypes.prf: Take abi into account for *_metatypes.json file names

Alexey Edelev (1):
      Do not revert properties of deleted objects

Allan Sandfeld Jensen (1):
      Fix release-only windows builds

Andreas Buhr (2):
      Fix QQuickShortcut::setContext so re-grab all shortcuts
      Change QQuickShortcut::setSequences to bind to all sequences

Andreas Hartmetz (1):
      QQuickWindow: don't leak old screenChanged connections

Andrei Golubev (1):
      Fix QML property cache leaks of delegate items

Andy Shaw (3):
      Show a tableview even if the syncView has an empty model
      Ensure that the case of the path will match then QUrl for a UNC path
      Remove unnecessary forward declaration

Antonio Rojas (1):
      Add missing limits include to fix build with GCC 11

Antti Kokko (1):
      Add changes file for Qt 5.15.2

Bartlomiej Moskal (4):
      QQuickWindow: Check if QQuickItem was not deleted
      qquicktextinput: Fix Undo history for IM event
      qquicktextinput: Fix validation for IM event
      QQuickTextControl: commit pre-edit after key press

Dmitry Shachnev (1):
      Include <limits> in Yarr.h to fix build with GCC 11

Edward Welbourne (1):
      Correct #if-ery in QML locale's time-zone update test

Eskil Abrahamsen Blomfeldt (1):
      Fix distorted text with subpixel matrix translation

Fabian Kosmale (15):
      Inline components: Fix custom parser support
      QQuickView docs: show correct usage of setInitialProperties
      QQuickTextInput: Store mask data in std::unique_ptr
      QML: Fix proxy iteration
      Fix IC properties in same file
      Fix Text with ElideRight not being rendered when width goes from 0 to >0
      tst_EcmaScriptTests: Raise timeout
      ListModel: Fix move handling in sync
      QQmlIRLoader: Actually load RequiredPropertyExtraData
      QV4 Engine: Remove MSVC special casing
      QQmlPropertyPrivate::signalExpression: handle object being null
      QQmlIncubator: handle clear inside setinitialState
      QuickTest: Do not recurse forever on inline components in enumerateTestCases
      Assert that pointer is non-null
      QQuickItem: Guard against cycles in nextPrevItemInTabFocusChain

Fabio Falsini (1):
      QQuickItemParticle give() method kill particle

Ivan Solovev (1):
      QuickLayouts: fix crash when layout width depends on parent width

Jan Arve SÃ¦ther (5):
      export QAcccessibleQuickItem
      QQmlProperty: Guard QQmlContextData with QQmlGuardedContextData
      QQuickListView: Add autotest so that animated delegate does not crash
      DelegateModelGroup: Fix bug where item could be removed from the model
      Fix TapHandler so that it actually registers a tap

Jani Heikkinen (2):
      Bump version
      Bump version

Joni Poikelin (1):
      Fix crash during model reset

Kimmo Ollila (1):
      Avoid GHS linker to optimize away QML type registrations

Laszlo Agocs (6):
      Add Lancelot tests for both types of clipping
      Regenerate Shape fill geometry when alpha changes to non-zero
      Revert "Set the stencil buffer zone" and "Add clipNext null pointer guard"
      Fix incorrect depth test state with QSGRenderNode::DepthAwareRendering
      Do not batch lines with > 1 width in alpha pass
      Revert "Fix for possible crash in QSGDefaultLayer::grab"

Li Xinwei (1):
      Use load(qt_tool) for qmltime

Marc Mutz (1):
      QQmlJs::FixedPoolArray: fix UB (precondition violation) in allocate()

Maximilian Goldstein (8):
      Revert "qquickloader: Free memory of loaded components after source change"
      qmlfunctions.qdoc: Add clarification to QML_FOREIGN
      qv4qmlcontext: Fix bounded signal expressions when debugging
      qqmlistmodel: Fix crash when modelCache is null
      qmlplugindump: Fix overload ambiguity
      qv4generatorobject: Fix crash when creating new properties
      qqmldelegatemodel: Fix out of bounds cache removal
      qqmlapplicationengine: Handle errors during component creation

Michael Brasser (1):
      Do less work when there are no active ImageParticle particles

Miikka Heikkinen (1):
      DesignerSupport: Don't skip already inspected objects

Mike Achtelik (1):
      QQuickWindowIncubationController: Use QPointer to guard QSGRenderLoop reference

Mitch Curtis (2):
      Doc: mention that INCLUDEPATH must be set in some cases
      Doc: mention that Item's childrenRect property is local to the item

Paul Wicking (1):
      Doc: Fix broken QDoc markup

Piotr Mikolajczyk (1):
      Accessibility event is sent on item's geometry change

Richard Moe Gustavsen (4):
      qquicktextinput: ensure we update IM when cursor changes position
      QQuickTextEdit: ensure we update after changing padding
      QQuickTableView: forceLayout() should work, even when no items are loaded
      QQuickTableView: always update content size when rebuilding small tables

Richard Weickelt (1):
      Fix crash when calling hasOwnProperty() on proxy object

Shawn Rutledge (4):
      doc: explain QQItem event delivery, handlers, setAcceptTouchEvents()
      docs: Fix documentation of the Locale numberOptions property
      doc: fix up QQuickItem::contains() docs
      Prevent infinite recursion in QQuickItemPrivate::itemToWindowTransform

Shinichi Okada (1):
      QML Text doesn't reset lineCount when text is empty

Siyeon Seo (1):
      Avoid crash when accessing an empty QTextLine

Tarja Sundqvist (3):
      Update commercial license headers
      Revert "Update commercial license headers"
      Merge remote-tracking branch 'origin/tqtc/lts-5.15.4' into tqtc/lts-5.15-opensource

Ulf Hermann (10):
      JIT: When making memory writable, include the exception handler
      masm: Add error handling for failed mprotect()
      Remove QQmlCleanup from QQmlScriptData
      Cache static compilation units
      QAnimationGroupJob: Don't call virtual functions from dtor
      QSequentialAnimationGroupJob: Protect against self-deletion
      Fix lookup of existing inline components by name
      Do not auto-clean components with live inline components
      Don't crash when trying to invoke non-existing string converter
      V4: Do not call dtor of an object we continue to use

Vlad Zahorodnii (2):
      Fix sweep step for tainted QObject JavaScript wrappers
      Make sure QQuickWidget and its offscreen window's screens are always in sync

Volker Hilsheimer (4):
      MouseArea: fix containsMouse behavior during visibility changes
      Use unique_ptr to clarify ownership of QQuickDefaultClipNode objects
      Revert "Use unique_ptr to clarify ownership of QQuickDefaultClipNode objects"
      QQuickItemAnimation: close potential memory leak

Wang Chuan (2):
      QQuickLoader: prevent clearing initial properties after active = true
      QQuickTextInput: update cursor rectangle after padding changed

diff --git a/examples/qml/doc/src/qml-extending.qdoc b/examples/qml/doc/src/qml-extending.qdoc
index 723e470d45..c9922ebd45 100644
--- a/examples/qml/doc/src/qml-extending.qdoc
+++ b/examples/qml/doc/src/qml-extending.qdoc
@@ -79,6 +79,10 @@ Qt's internal QLineEdit class.
 
 \snippet referenceexamples/extended/lineedit.h 0
 
+Note the usage of \l QML_NAMED_ELEMENT() instead of \l QML_ELEMENT.
+QML_ELEMENT uses the name of the containing type by default, "LineEditExtension" in this case.
+As the class being an extension class is an implementation detail, we choose the more natural name "LineEdit" instead
+
 The QML engine then instantiates a \l QLineEdit:
 
 \snippet referenceexamples/extended/main.cpp 1
diff --git a/src/3rdparty/masm/assembler/AbstractMacroAssembler.h b/src/3rdparty/masm/assembler/AbstractMacroAssembler.h
index 14644a4193..617eef351b 100644
--- a/src/3rdparty/masm/assembler/AbstractMacroAssembler.h
+++ b/src/3rdparty/masm/assembler/AbstractMacroAssembler.h
@@ -51,7 +51,6 @@ template <typename, template <typename> class>
 class LinkBufferBase;
 template <typename>
 class BranchCompactingLinkBuffer;
-class RepatchBuffer;
 class Watchpoint;
 namespace DFG {
 struct OSRExit;
@@ -831,7 +830,6 @@ protected:
 
     template <typename, template <typename> class> friend class LinkBufferBase;
     template <typename> friend class BranchCompactingLinkBuffer;
-    friend class RepatchBuffer;
 
     static void linkJump(void* code, Jump jump, CodeLocationLabel target)
     {
diff --git a/src/3rdparty/masm/assembler/AssemblerBuffer.h b/src/3rdparty/masm/assembler/AssemblerBuffer.h
index 45874235b6..58ecac2a4a 100644
--- a/src/3rdparty/masm/assembler/AssemblerBuffer.h
+++ b/src/3rdparty/masm/assembler/AssemblerBuffer.h
@@ -140,9 +140,10 @@ namespace JSC {
             if (!result)
                 return 0;
 
-            ExecutableAllocator::makeWritable(result->start(), result->sizeInBytes());
+            if (Q_UNLIKELY(!ExecutableAllocator::makeWritable(result->memoryStart(), result->memorySize())))
+                return 0;
 
-            memcpy(result->start(), m_buffer, m_index);
+            memcpy(result->codeStart(), m_buffer, m_index);
             
             return result.release();
         }
diff --git a/src/3rdparty/masm/assembler/LinkBuffer.h b/src/3rdparty/masm/assembler/LinkBuffer.h
index ba57564a1d..f1a6639b73 100644
--- a/src/3rdparty/masm/assembler/LinkBuffer.h
+++ b/src/3rdparty/masm/assembler/LinkBuffer.h
@@ -228,7 +228,7 @@ public:
         return m_size;
     }
 
-    inline void makeExecutable();
+    inline bool makeExecutable();
 
 private:
     template <typename T> T applyOffset(T src)
@@ -333,7 +333,7 @@ inline void LinkBufferBase<MacroAssembler, ExecutableOffsetCalculator>::linkCode
     m_executableMemory = m_assembler->m_assembler.executableCopy(*m_globalData, ownerUID, effort);
     if (!m_executableMemory)
         return;
-    m_code = m_executableMemory->start();
+    m_code = m_executableMemory->codeStart();
     m_size = m_assembler->m_assembler.codeSize();
     ASSERT(m_code);
 }
@@ -353,9 +353,10 @@ void LinkBufferBase<MacroAssembler, ExecutableOffsetCalculator>::performFinaliza
 }
 
 template <typename MacroAssembler, template <typename T> class ExecutableOffsetCalculator>
-inline void LinkBufferBase<MacroAssembler, ExecutableOffsetCalculator>::makeExecutable()
+inline bool LinkBufferBase<MacroAssembler, ExecutableOffsetCalculator>::makeExecutable()
 {
-    ExecutableAllocator::makeExecutable(code(), static_cast<int>(m_size));
+    return ExecutableAllocator::makeExecutable(m_executableMemory->memoryStart(),
+                                               m_executableMemory->memorySize());
 }
 
 template <typename MacroAssembler>
@@ -391,7 +392,7 @@ public:
     }
 
     virtual void performFinalization() override final;
-    inline void makeExecutable();
+    inline bool makeExecutable();
 
     inline void linkCode(void* ownerUID, JITCompilationEffort);
 
@@ -427,9 +428,9 @@ void BranchCompactingLinkBuffer<MacroAssembler>::performFinalization()
 }
 
 template <typename MacroAssembler>
-inline void BranchCompactingLinkBuffer<MacroAssembler>::makeExecutable()
+inline bool BranchCompactingLinkBuffer<MacroAssembler>::makeExecutable()
 {
-    ExecutableAllocator::makeExecutable(code(), m_initialSize);
+    return ExecutableAllocator::makeExecutable(code(), m_initialSize);
 }
 
 template <typename MacroAssembler>
@@ -442,9 +443,12 @@ inline void BranchCompactingLinkBuffer<MacroAssembler>::linkCode(void* ownerUID,
     m_executableMemory = m_globalData->executableAllocator.allocate(*m_globalData, m_initialSize, ownerUID, effort);
     if (!m_executableMemory)
         return;
-    m_code = (uint8_t*)m_executableMemory->start();
+    if (Q_UNLIKELY(!ExecutableAllocator::makeWritable(m_executableMemory->memoryStart(), m_executableMemory->memorySize()))) {
+        m_executableMemory = {};
+        return;
+    }
+    m_code = (uint8_t*)m_executableMemory->codeStart();
     ASSERT(m_code);
-    ExecutableAllocator::makeWritable(m_code, m_initialSize);
     uint8_t* inData = (uint8_t*)m_assembler->unlinkedCode();
     uint8_t* outData = reinterpret_cast<uint8_t*>(m_code);
     int readPtr = 0;
diff --git a/src/3rdparty/masm/assembler/MacroAssemblerARMv7.h b/src/3rdparty/masm/assembler/MacroAssemblerARMv7.h
index 6232834fde..1ccea63d23 100644
--- a/src/3rdparty/masm/assembler/MacroAssemblerARMv7.h
+++ b/src/3rdparty/masm/assembler/MacroAssemblerARMv7.h
@@ -1955,7 +1955,6 @@ protected:
     
 private:
     template <typename, template <typename> class> friend class LinkBufferBase;
-    friend class RepatchBuffer;
 
     static void linkCall(void* code, Call call, FunctionPtr function)
     {
diff --git a/src/3rdparty/masm/assembler/MacroAssemblerCodeRef.h b/src/3rdparty/masm/assembler/MacroAssemblerCodeRef.h
index a7e78ad78f..cde9751108 100644
--- a/src/3rdparty/masm/assembler/MacroAssemblerCodeRef.h
+++ b/src/3rdparty/masm/assembler/MacroAssemblerCodeRef.h
@@ -357,11 +357,11 @@ public:
     }
 
     MacroAssemblerCodeRef(PassRefPtr<ExecutableMemoryHandle> executableMemory)
-        : m_codePtr(executableMemory->start())
+        : m_codePtr(executableMemory->codeStart())
         , m_executableMemory(executableMemory)
     {
         ASSERT(m_executableMemory->isManaged());
-        ASSERT(m_executableMemory->start());
+        ASSERT(m_executableMemory->codeStart());
         ASSERT(m_codePtr);
     }
     
@@ -395,7 +395,7 @@ public:
     {
         if (!m_executableMemory)
             return 0;
-        return m_executableMemory->sizeInBytes();
+        return m_executableMemory->codeSize();
     }
     
     bool tryToDisassemble(const char* prefix) const
diff --git a/src/3rdparty/masm/assembler/MacroAssemblerMIPS.h b/src/3rdparty/masm/assembler/MacroAssemblerMIPS.h
index 07f0ec623f..6dfc104823 100644
--- a/src/3rdparty/masm/assembler/MacroAssemblerMIPS.h
+++ b/src/3rdparty/masm/assembler/MacroAssemblerMIPS.h
@@ -2818,7 +2818,6 @@ private:
     bool m_fixedWidth;
 
     template <typename, template <typename> class> friend class LinkBufferBase;
-    friend class RepatchBuffer;
 
     static void linkCall(void* code, Call call, FunctionPtr function)
     {
diff --git a/src/3rdparty/masm/assembler/MacroAssemblerX86.h b/src/3rdparty/masm/assembler/MacroAssemblerX86.h
index 5cffa787ec..390a054468 100644
--- a/src/3rdparty/masm/assembler/MacroAssemblerX86.h
+++ b/src/3rdparty/masm/assembler/MacroAssemblerX86.h
@@ -313,7 +313,6 @@ public:
 
 private:
     template <typename, template <typename> class> friend class LinkBufferBase;
-    friend class RepatchBuffer;
 
     static void linkCall(void* code, Call call, FunctionPtr function)
     {
diff --git a/src/3rdparty/masm/assembler/MacroAssemblerX86_64.h b/src/3rdparty/masm/assembler/MacroAssemblerX86_64.h
index 0a6db0805b..3be7cc2669 100644
--- a/src/3rdparty/masm/assembler/MacroAssemblerX86_64.h
+++ b/src/3rdparty/masm/assembler/MacroAssemblerX86_64.h
@@ -733,7 +733,6 @@ public:
 
 private:
     template <typename, template <typename> class> friend class LinkBufferBase;
-    friend class RepatchBuffer;
 
     static void linkCall(void* code, Call call, FunctionPtr function)
     {
diff --git a/src/3rdparty/masm/assembler/RepatchBuffer.h b/src/3rdparty/masm/assembler/RepatchBuffer.h
deleted file mode 100644
index dbb56f9ad5..0000000000
--- a/src/3rdparty/masm/assembler/RepatchBuffer.h
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (C) 2009 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
- */
-
-#ifndef RepatchBuffer_h
-#define RepatchBuffer_h
-
-#if ENABLE(JIT)
-
-#include "CodeBlock.h"
-#include <MacroAssembler.h>
-#include <wtf/Noncopyable.h>
-
-namespace JSC {
-
-// RepatchBuffer:
-//
-// This class is used to modify code after code generation has been completed,
-// and after the code has potentially already been executed.  This mechanism is
-// used to apply optimizations to the code.
-//
-class RepatchBuffer {
-    typedef MacroAssemblerCodePtr CodePtr;
-
-public:
-    RepatchBuffer(CodeBlock* codeBlock)
-    {
-        JITCode& code = codeBlock->getJITCode();
-        m_start = code.start();
-        m_size = code.size();
-
-        ExecutableAllocator::makeWritable(m_start, m_size);
-    }
-
-    ~RepatchBuffer()
-    {
-        ExecutableAllocator::makeExecutable(m_start, m_size);
-    }
-
-    void relink(CodeLocationJump jump, CodeLocationLabel destination)
-    {
-        MacroAssembler::repatchJump(jump, destination);
-    }
-
-    void relink(CodeLocationCall call, CodeLocationLabel destination)
-    {
-        MacroAssembler::repatchCall(call, destination);
-    }
-
-    void relink(CodeLocationCall call, FunctionPtr destination)
-    {
-        MacroAssembler::repatchCall(call, destination);
-    }
-
-    void relink(CodeLocationNearCall nearCall, CodePtr destination)
-    {
-        MacroAssembler::repatchNearCall(nearCall, CodeLocationLabel(destination));
-    }
-
-    void relink(CodeLocationNearCall nearCall, CodeLocationLabel destination)
-    {
-        MacroAssembler::repatchNearCall(nearCall, destination);
-    }
-
-    void repatch(CodeLocationDataLabel32 dataLabel32, int32_t value)
-    {
-        MacroAssembler::repatchInt32(dataLabel32, value);
-    }
-
-    void repatch(CodeLocationDataLabelCompact dataLabelCompact, int32_t value)
-    {
-        MacroAssembler::repatchCompact(dataLabelCompact, value);
-    }
-
-    void repatch(CodeLocationDataLabelPtr dataLabelPtr, void* value)
-    {
-        MacroAssembler::repatchPointer(dataLabelPtr, value);
-    }
-
-    void relinkCallerToTrampoline(ReturnAddressPtr returnAddress, CodeLocationLabel label)
-    {
-        relink(CodeLocationCall(CodePtr(returnAddress)), label);
-    }
-    
-    void relinkCallerToTrampoline(ReturnAddressPtr returnAddress, CodePtr newCalleeFunction)
-    {
-        relinkCallerToTrampoline(returnAddress, CodeLocationLabel(newCalleeFunction));
-    }
-
-    void relinkCallerToFunction(ReturnAddressPtr returnAddress, FunctionPtr function)
-    {
-        relink(CodeLocationCall(CodePtr(returnAddress)), function);
-    }
-    
-    void relinkNearCallerToTrampoline(ReturnAddressPtr returnAddress, CodeLocationLabel label)
-    {
-        relink(CodeLocationNearCall(CodePtr(returnAddress)), label);
-    }
-    
-    void relinkNearCallerToTrampoline(ReturnAddressPtr returnAddress, CodePtr newCalleeFunction)
-    {
-        relinkNearCallerToTrampoline(returnAddress, CodeLocationLabel(newCalleeFunction));
-    }
-    
-    void replaceWithLoad(CodeLocationConvertibleLoad label)
-    {
-        MacroAssembler::replaceWithLoad(label);
-    }
-    
-    void replaceWithAddressComputation(CodeLocationConvertibleLoad label)
-    {
-        MacroAssembler::replaceWithAddressComputation(label);
-    }
-    
-    void setLoadInstructionIsActive(CodeLocationConvertibleLoad label, bool isActive)
-    {
-        if (isActive)
-            replaceWithLoad(label);
-        else
-            replaceWithAddressComputation(label);
-    }
-
-    static CodeLocationLabel startOfBranchPtrWithPatchOnRegister(CodeLocationDataLabelPtr label)
-    {
-        return MacroAssembler::startOfBranchPtrWithPatchOnRegister(label);
-    }
-    
-    static CodeLocationLabel startOfPatchableBranchPtrWithPatchOnAddress(CodeLocationDataLabelPtr label)
-    {
-        return MacroAssembler::startOfPatchableBranchPtrWithPatchOnAddress(label);
-    }
-    
-    void replaceWithJump(CodeLocationLabel instructionStart, CodeLocationLabel destination)
-    {
-        MacroAssembler::replaceWithJump(instructionStart, destination);
-    }
-    
-    // This is a *bit* of a silly API, since we currently always also repatch the
-    // immediate after calling this. But I'm fine with that, since this just feels
-    // less yucky.
-    void revertJumpReplacementToBranchPtrWithPatch(CodeLocationLabel instructionStart, MacroAssembler::RegisterID reg, void* value)
-    {
-        MacroAssembler::revertJumpReplacementToBranchPtrWithPatch(instructionStart, reg, value);
-    }
-
-    void revertJumpReplacementToPatchableBranchPtrWithPatch(CodeLocationLabel instructionStart, MacroAssembler::Address address, void* value)
-    {
-        MacroAssembler::revertJumpReplacementToPatchableBranchPtrWithPatch(instructionStart, address, value);
-    }
-
-private:
-    void* m_start;
-    size_t m_size;
-};
-
-} // namespace JSC
-
-#endif // ENABLE(ASSEMBLER)
-
-#endif // RepatchBuffer_h
diff --git a/src/3rdparty/masm/stubs/ExecutableAllocator.h b/src/3rdparty/masm/stubs/ExecutableAllocator.h
index a439c53827..515285a7dc 100644
--- a/src/3rdparty/masm/stubs/ExecutableAllocator.h
+++ b/src/3rdparty/masm/stubs/ExecutableAllocator.h
@@ -82,9 +82,14 @@ struct ExecutableMemoryHandle : public RefCounted<ExecutableMemoryHandle> {
 
     inline bool isManaged() const { return true; }
 
-    void *exceptionHandler() { return m_allocation->exceptionHandler(); }
-    void *start() { return m_allocation->start(); }
-    size_t sizeInBytes() { return m_size; }
+    void *memoryStart() { return m_allocation->memoryStart(); }
+    size_t memorySize() { return m_allocation->memorySize(); }
+
+    void *exceptionHandlerStart() { return m_allocation->exceptionHandlerStart(); }
+    size_t exceptionHandlerSize() { return m_allocation->exceptionHandlerSize(); }
+
+    void *codeStart() { return m_allocation->codeStart(); }
+    size_t codeSize() { return m_size; }
 
     QV4::ExecutableAllocator::ChunkOfPages *chunk() const
     { return m_allocator->chunkForAllocation(m_allocation); }
@@ -104,7 +109,7 @@ struct ExecutableAllocator {
         return adoptRef(new ExecutableMemoryHandle(realAllocator, size));
     }
 
-    static void makeWritable(void* addr, size_t size)
+    static bool makeWritable(void* addr, size_t size)
     {
         quintptr pageSize = WTF::pageSize();
         quintptr iaddr = reinterpret_cast<quintptr>(addr);
@@ -120,7 +125,7 @@ struct ExecutableAllocator {
 #    else
         bool hr = VirtualProtectFromApp(addr, size, PAGE_READWRITE, &oldProtect);
         if (!hr) {
-            Q_UNREACHABLE();
+            return false;
         }
 #    endif
 #  elif OS(INTEGRITY)
@@ -129,7 +134,7 @@ struct ExecutableAllocator {
         int mode = PROT_READ | PROT_WRITE;
         if (mprotect(addr, size, mode) != 0) {
             perror("mprotect failed in ExecutableAllocator::makeWritable");
-            Q_UNREACHABLE();
+            return false;
         }
 #  endif
 #else
@@ -137,9 +142,10 @@ struct ExecutableAllocator {
         (void)addr; // suppress unused parameter warning
         (void)size; // suppress unused parameter warning
 #endif
+        return true;
     }
 
-    static void makeExecutable(void* addr, size_t size)
+    static bool makeExecutable(void* addr, size_t size)
     {
         quintptr pageSize = WTF::pageSize();
         quintptr iaddr = reinterpret_cast<quintptr>(addr);
@@ -156,7 +162,7 @@ struct ExecutableAllocator {
 #    else
         bool hr = VirtualProtectFromApp(addr, size, PAGE_EXECUTE_READ, &oldProtect);
         if (!hr) {
-            Q_UNREACHABLE();
+            return false;
         }
 #    endif
 #  elif OS(INTEGRITY)
@@ -165,7 +171,7 @@ struct ExecutableAllocator {
         int mode = PROT_READ | PROT_EXEC;
         if (mprotect(addr, size, mode) != 0) {
             perror("mprotect failed in ExecutableAllocator::makeExecutable");
-            Q_UNREACHABLE();
+            return false;
         }
 #  endif
 #else
@@ -175,6 +181,7 @@ struct ExecutableAllocator {
         (void)addr; // suppress unused parameter warning
         (void)size; // suppress unused parameter warning
 #endif
+        return true;
     }
 
     QV4::ExecutableAllocator *realAllocator;
diff --git a/src/3rdparty/masm/yarr/Yarr.h b/src/3rdparty/masm/yarr/Yarr.h
index ccf78f9880..2955ea7e72 100644
--- a/src/3rdparty/masm/yarr/Yarr.h
+++ b/src/3rdparty/masm/yarr/Yarr.h
@@ -28,6 +28,7 @@
 #pragma once
 
 #include <limits.h>
+#include <limits>
 #include "YarrErrorCode.h"
 
 namespace JSC { namespace Yarr {
diff --git a/src/3rdparty/masm/yarr/YarrJIT.cpp b/src/3rdparty/masm/yarr/YarrJIT.cpp
index 1c8138c66e..28ca8e2629 100644
--- a/src/3rdparty/masm/yarr/YarrJIT.cpp
+++ b/src/3rdparty/masm/yarr/YarrJIT.cpp
@@ -3928,7 +3928,8 @@ public:
         }
         QV4::generateFunctionTable(nullptr, &codeRef);
 
-        linkBuffer.makeExecutable();
+        if (Q_UNLIKELY(!linkBuffer.makeExecutable()))
+            m_failureReason = JITFailureReason::ExecutableMemoryAllocationFailure;
 
         if (m_failureReason)
             codeBlock.setFallBackWithFailureReason(*m_failureReason);
diff --git a/src/imports/folderlistmodel/plugin.cpp b/src/imports/folderlistmodel/plugin.cpp
index 7a38769b77..7206df6664 100644
--- a/src/imports/folderlistmodel/plugin.cpp
+++ b/src/imports/folderlistmodel/plugin.cpp
@@ -43,6 +43,7 @@
 #include "qquickfolderlistmodel.h"
 
 extern void qml_register_types_Qt_labs_folderlistmodel();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_folderlistmodel);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/labsanimation/plugin.cpp b/src/imports/labsanimation/plugin.cpp
index 9c985f0dcf..c35be764f9 100644
--- a/src/imports/labsanimation/plugin.cpp
+++ b/src/imports/labsanimation/plugin.cpp
@@ -43,6 +43,7 @@
 #include "qquickboundaryrule_p.h"
 
 extern void qml_register_types_Qt_labs_animation();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_animation);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/labsmodels/plugin.cpp b/src/imports/labsmodels/plugin.cpp
index ab5e0023a6..b06491e663 100644
--- a/src/imports/labsmodels/plugin.cpp
+++ b/src/imports/labsmodels/plugin.cpp
@@ -51,6 +51,7 @@
 #endif
 
 extern void qml_register_types_Qt_labs_qmlmodels();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_qmlmodels);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/layouts/plugin.cpp b/src/imports/layouts/plugin.cpp
index af270c1732..b6ae516eee 100644
--- a/src/imports/layouts/plugin.cpp
+++ b/src/imports/layouts/plugin.cpp
@@ -43,6 +43,7 @@
 #include "qquickstacklayout_p.h"
 
 extern void qml_register_types_QtQuick_Layouts();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_Layouts);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/layouts/qquicklinearlayout.cpp b/src/imports/layouts/qquicklinearlayout.cpp
index 4df264f264..dbd56b1996 100644
--- a/src/imports/layouts/qquicklinearlayout.cpp
+++ b/src/imports/layouts/qquicklinearlayout.cpp
@@ -470,8 +470,6 @@ void QQuickGridLayoutBase::rearrange(const QSizeF &size)
     if (!isReady())
         return;
 
-    ensureLayoutItemsUpdated();
-
     qCDebug(lcQuickLayouts) << "QQuickGridLayoutBase::rearrange" << d->m_recurRearrangeCounter << this;
     const auto refCounter = qScopeGuard([&d] {
         --(d->m_recurRearrangeCounter);
@@ -483,6 +481,8 @@ void QQuickGridLayoutBase::rearrange(const QSizeF &size)
         return;
     }
 
+    ensureLayoutItemsUpdated();
+
     d->m_rearranging = true;
     qCDebug(lcQuickLayouts) << objectName() << "QQuickGridLayoutBase::rearrange()" << size;
     Qt::LayoutDirection visualDir = effectiveLayoutDirection();
diff --git a/src/imports/localstorage/plugin.cpp b/src/imports/localstorage/plugin.cpp
index e488b3d43c..0291ed4715 100644
--- a/src/imports/localstorage/plugin.cpp
+++ b/src/imports/localstorage/plugin.cpp
@@ -43,6 +43,7 @@
 #include <QtQml/qqml.h>
 
 extern void qml_register_types_QtQuick_LocalStorage();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_LocalStorage);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/settings/plugin.cpp b/src/imports/settings/plugin.cpp
index e8e640412b..e83147f612 100644
--- a/src/imports/settings/plugin.cpp
+++ b/src/imports/settings/plugin.cpp
@@ -43,6 +43,7 @@
 #include "qqmlsettings_p.h"
 
 extern void qml_register_types_Qt_labs_settings();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_settings);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/sharedimage/plugin.cpp b/src/imports/sharedimage/plugin.cpp
index d7c2ef8d17..79168d933b 100644
--- a/src/imports/sharedimage/plugin.cpp
+++ b/src/imports/sharedimage/plugin.cpp
@@ -100,6 +100,7 @@
 */
 
 extern void qml_register_types_Qt_labs_sharedimage();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_sharedimage);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/statemachine/plugin.cpp b/src/imports/statemachine/plugin.cpp
index c370504029..abb238965e 100644
--- a/src/imports/statemachine/plugin.cpp
+++ b/src/imports/statemachine/plugin.cpp
@@ -49,6 +49,7 @@
 #include <qqml.h>
 
 extern void qml_register_types_QtQml_StateMachine();
+GHS_KEEP_REFERENCE(qml_register_types_QtQml_StateMachine);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/testlib/main.cpp b/src/imports/testlib/main.cpp
index 83fc150e6c..1da251c49b 100644
--- a/src/imports/testlib/main.cpp
+++ b/src/imports/testlib/main.cpp
@@ -51,6 +51,7 @@ QML_DECLARE_TYPE(QuickTestEvent)
 QML_DECLARE_TYPE(QuickTestUtil)
 
 extern void qml_register_types_QtTest();
+GHS_KEEP_REFERENCE(qml_register_types_QtTest);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/wavefrontmesh/plugin.cpp b/src/imports/wavefrontmesh/plugin.cpp
index eea0db19db..edd4d1dba5 100644
--- a/src/imports/wavefrontmesh/plugin.cpp
+++ b/src/imports/wavefrontmesh/plugin.cpp
@@ -43,6 +43,7 @@
 #include "qwavefrontmesh.h"
 
 extern void qml_register_types_Qt_labs_wavefrontmesh();
+GHS_KEEP_REFERENCE(qml_register_types_Qt_labs_wavefrontmesh);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/imports/window/plugin.cpp b/src/imports/window/plugin.cpp
index 5152fa02ec..ff2f10fde3 100644
--- a/src/imports/window/plugin.cpp
+++ b/src/imports/window/plugin.cpp
@@ -42,6 +42,7 @@
 #include "plugin.h"
 
 extern void qml_register_types_QtQuick_Window();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_Window);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/particles/qquickimageparticle.cpp b/src/particles/qquickimageparticle.cpp
index 4d67691771..d2a0e5545b 100644
--- a/src/particles/qquickimageparticle.cpp
+++ b/src/particles/qquickimageparticle.cpp
@@ -1132,6 +1132,7 @@ QQuickImageParticle::QQuickImageParticle(QQuickItem* parent)
     , m_startedImageLoading(0)
     , m_rhi(nullptr)
     , m_apiChecked(false)
+    , m_previousActive(false)
 {
     setFlag(ItemHasContents);
 }
@@ -1960,11 +1961,13 @@ QSGNode *QQuickImageParticle::updatePaintNode(QSGNode *node, UpdatePaintNodeData
     }
 
     if (m_system && m_system->isRunning() && !m_system->isPaused()){
-        prepareNextFrame(&node);
+        bool dirty = prepareNextFrame(&node);
         if (node) {
             update();
-            foreach (QSGGeometryNode* n, m_nodes)
-                n->markDirty(QSGNode::DirtyGeometry);
+            if (dirty) {
+                foreach (QSGGeometryNode* n, m_nodes)
+                    n->markDirty(QSGNode::DirtyGeometry);
+            }
         } else if (m_startedImageLoading < 2) {
             update();//To call prepareNextFrame() again from the renderThread
         }
@@ -1978,7 +1981,7 @@ QSGNode *QQuickImageParticle::updatePaintNode(QSGNode *node, UpdatePaintNodeData
     return node;
 }
 
-void QQuickImageParticle::prepareNextFrame(QSGNode **node)
+bool QQuickImageParticle::prepareNextFrame(QSGNode **node)
 {
     if (*node == nullptr){//TODO: Staggered loading (as emitted)
         buildParticleNodes(node);
@@ -1994,7 +1997,7 @@ void QQuickImageParticle::prepareNextFrame(QSGNode **node)
             qDebug() << "Total count: " << count;
         }
         if (*node == nullptr)
-            return;
+            return false;
     }
     qint64 timeStamp = m_system->systemSync(this);
 
@@ -2015,8 +2018,23 @@ void QQuickImageParticle::prepareNextFrame(QSGNode **node)
         getState(m_material)->timestamp = time;
         break;
     }
-    foreach (QSGGeometryNode* node, m_nodes)
-        node->markDirty(QSGNode::DirtyMaterial);
+
+    bool active = false;
+    for (auto groupId : groupIds()) {
+        if (m_system->groupData[groupId]->isActive()) {
+            active = true;
+            break;
+        }
+    }
+
+    const bool dirty = active || m_previousActive;
+    if (dirty) {
+        foreach (QSGGeometryNode* node, m_nodes)
+            node->markDirty(QSGNode::DirtyMaterial);
+    }
+
+    m_previousActive = active;
+    return dirty;
 }
 
 void QQuickImageParticle::spritesUpdate(qreal time)
diff --git a/src/particles/qquickimageparticle_p.h b/src/particles/qquickimageparticle_p.h
index fdb404861c..b5fdfdadc9 100644
--- a/src/particles/qquickimageparticle_p.h
+++ b/src/particles/qquickimageparticle_p.h
@@ -363,7 +363,7 @@ protected:
     void commit(int gIdx, int pIdx) override;
 
     QSGNode *updatePaintNode(QSGNode *, UpdatePaintNodeData *) override;
-    void prepareNextFrame(QSGNode**);
+    bool prepareNextFrame(QSGNode**);
     void buildParticleNodes(QSGNode**);
 
     void sceneGraphInvalidated() override;
@@ -460,6 +460,7 @@ private:
     int m_startedImageLoading;
     QRhi *m_rhi;
     bool m_apiChecked;
+    bool m_previousActive;
 };
 
 QT_END_NAMESPACE
diff --git a/src/particles/qquickitemparticle.cpp b/src/particles/qquickitemparticle.cpp
index ce254c212d..60d368a2a3 100644
--- a/src/particles/qquickitemparticle.cpp
+++ b/src/particles/qquickitemparticle.cpp
@@ -165,6 +165,7 @@ void QQuickItemParticle::give(QQuickItem *item)
             if (data->delegate == item){
                 m_deletables << item;
                 data->delegate = nullptr;
+                m_system->groupData[groupId]->kill(data);
                 return;
             }
         }
diff --git a/src/particles/qquickparticlesystem_p.h b/src/particles/qquickparticlesystem_p.h
index ea890d20f4..c74be45c7a 100644
--- a/src/particles/qquickparticlesystem_p.h
+++ b/src/particles/qquickparticlesystem_p.h
@@ -205,6 +205,8 @@ public:
 
     QString name();
 
+    bool isActive() { return freeList.count() > 0; }
+
     void setSize(int newSize);
 
     const ID index;
diff --git a/src/particles/qtquickparticlesglobal_p.h b/src/particles/qtquickparticlesglobal_p.h
index 927bc29050..91c2764060 100644
--- a/src/particles/qtquickparticlesglobal_p.h
+++ b/src/particles/qtquickparticlesglobal_p.h
@@ -66,5 +66,6 @@
 #endif
 
 void Q_QUICKPARTICLES_PRIVATE_EXPORT qml_register_types_QtQuick_Particles();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_Particles);
 
 #endif // QTQUICKPARTICLESGLOBAL_P_H
diff --git a/src/qml/animations/qanimationgroupjob.cpp b/src/qml/animations/qanimationgroupjob.cpp
index 66599561fc..60b3003d0a 100644
--- a/src/qml/animations/qanimationgroupjob.cpp
+++ b/src/qml/animations/qanimationgroupjob.cpp
@@ -47,9 +47,45 @@ QAnimationGroupJob::QAnimationGroupJob()
     m_isGroup = true;
 }
 
+void QAnimationGroupJob::ungroupChild(QAbstractAnimationJob *animation)
+{
+    Q_ASSERT(animation);
+    Q_ASSERT(animation->m_group == this);
+    QAbstractAnimationJob *prev = animation->previousSibling();
+    QAbstractAnimationJob *next = animation->nextSibling();
+
+    if (prev)
+        prev->m_nextSibling = next;
+    else
+        m_firstChild = next;
+
+    if (next)
+        next->m_previousSibling = prev;
+    else
+        m_lastChild = prev;
+
+    animation->m_previousSibling = nullptr;
+    animation->m_nextSibling = nullptr;
+
+    animation->m_group = nullptr;
+}
+
+void QAnimationGroupJob::handleAnimationRemoved(QAbstractAnimationJob *animation)
+{
+    resetUncontrolledAnimationFinishTime(animation);
+    if (!firstChild()) {
+        m_currentTime = 0;
+        stop();
+    }
+}
+
 QAnimationGroupJob::~QAnimationGroupJob()
 {
-    clear();
+    while (QAbstractAnimationJob *animation = firstChild()) {
+        ungroupChild(animation);
+        handleAnimationRemoved(animation);
+        delete animation;
+    }
 }
 
 void QAnimationGroupJob::topLevelAnimationLoopChanged()
@@ -96,25 +132,9 @@ void QAnimationGroupJob::prependAnimation(QAbstractAnimationJob *animation)
 
 void QAnimationGroupJob::removeAnimation(QAbstractAnimationJob *animation)
 {
-    Q_ASSERT(animation);
-    Q_ASSERT(animation->m_group == this);
     QAbstractAnimationJob *prev = animation->previousSibling();
     QAbstractAnimationJob *next = animation->nextSibling();
-
-    if (prev)
-        prev->m_nextSibling = next;
-    else
-        m_firstChild = next;
-
-    if (next)
-        next->m_previousSibling = prev;
-    else
-        m_lastChild = prev;
-
-    animation->m_previousSibling = nullptr;
-    animation->m_nextSibling = nullptr;
-
-    animation->m_group = nullptr;
+    ungroupChild(animation);
     animationRemoved(animation, prev, next);
 }
 
@@ -154,11 +174,7 @@ void QAnimationGroupJob::uncontrolledAnimationFinished(QAbstractAnimationJob *an
 
 void QAnimationGroupJob::animationRemoved(QAbstractAnimationJob* anim, QAbstractAnimationJob* , QAbstractAnimationJob* )
 {
-    resetUncontrolledAnimationFinishTime(anim);
-    if (!firstChild()) {
-        m_currentTime = 0;
-        stop();
-    }
+    handleAnimationRemoved(anim);
 }
 
 void QAnimationGroupJob::debugChildren(QDebug d) const
diff --git a/src/qml/animations/qanimationgroupjob_p.h b/src/qml/animations/qanimationgroupjob_p.h
index a27c9195dd..6a0941db65 100644
--- a/src/qml/animations/qanimationgroupjob_p.h
+++ b/src/qml/animations/qanimationgroupjob_p.h
@@ -91,6 +91,9 @@ protected:
     void debugChildren(QDebug d) const;
 
 private:
+    void ungroupChild(QAbstractAnimationJob *animation);
+    void handleAnimationRemoved(QAbstractAnimationJob *animation);
+
     //definition
     QAbstractAnimationJob *m_firstChild = nullptr;
     QAbstractAnimationJob *m_lastChild = nullptr;
diff --git a/src/qml/animations/qanimationjobutil_p.h b/src/qml/animations/qanimationjobutil_p.h
index 83cf3b246f..2b7bda3123 100644
--- a/src/qml/animations/qanimationjobutil_p.h
+++ b/src/qml/animations/qanimationjobutil_p.h
@@ -70,7 +70,7 @@ struct SelfDeletable {
 // \param func statements or functions that to be executed under test.
 // \param action post process if p was deleted under test.
 #define ACTION_IF_DELETED(p, func, action) \
-{ \
+do { \
     static_assert(std::is_same<decltype((p)->m_selfDeletable), SelfDeletable>::value, "m_selfDeletable must be SelfDeletable");\
     bool *prevWasDeleted = (p)->m_selfDeletable.m_wasDeleted; \
     bool wasDeleted = false; \
@@ -82,7 +82,7 @@ struct SelfDeletable {
         {action;} \
     } \
     (p)->m_selfDeletable.m_wasDeleted = prevWasDeleted; \
-}
+} while (false)
 
 #define RETURN_IF_DELETED(func) \
 ACTION_IF_DELETED(this, func, return)
diff --git a/src/qml/animations/qsequentialanimationgroupjob.cpp b/src/qml/animations/qsequentialanimationgroupjob.cpp
index dc57444b32..1d19bbf79d 100644
--- a/src/qml/animations/qsequentialanimationgroupjob.cpp
+++ b/src/qml/animations/qsequentialanimationgroupjob.cpp
@@ -338,7 +338,7 @@ void QSequentialAnimationGroupJob::uncontrolledAnimationFinished(QAbstractAnimat
     if (m_direction == Forward) {
         // set the current animation to be the next one
         if (m_currentAnimation->nextSibling())
-            setCurrentAnimation(m_currentAnimation->nextSibling());
+            RETURN_IF_DELETED(setCurrentAnimation(m_currentAnimation->nextSibling()));
 
         for (QAbstractAnimationJob *a = animation->nextSibling(); a; a = a->nextSibling()) {
             int dur = a->duration();
@@ -353,7 +353,7 @@ void QSequentialAnimationGroupJob::uncontrolledAnimationFinished(QAbstractAnimat
     } else {
         // set the current animation to be the previous one
         if (m_currentAnimation->previousSibling())
-            setCurrentAnimation(m_currentAnimation->previousSibling());
+            RETURN_IF_DELETED(setCurrentAnimation(m_currentAnimation->previousSibling()));
 
         for (QAbstractAnimationJob *a = animation->previousSibling(); a; a = a->previousSibling()) {
             int dur = a->duration();
@@ -374,12 +374,12 @@ void QSequentialAnimationGroupJob::uncontrolledAnimationFinished(QAbstractAnimat
 void QSequentialAnimationGroupJob::animationInserted(QAbstractAnimationJob *anim)
 {
     if (m_currentAnimation == nullptr)
-        setCurrentAnimation(firstChild()); // initialize the current animation
+        RETURN_IF_DELETED(setCurrentAnimation(firstChild())); // initialize the current animation
 
     if (m_currentAnimation == anim->nextSibling()
         && m_currentAnimation->currentTime() == 0 && m_currentAnimation->currentLoop() == 0) {
             //in this case we simply insert the animation before the current one has actually started
-            setCurrentAnimation(anim);
+            RETURN_IF_DELETED(setCurrentAnimation(anim));
     }
 
 //    TODO
@@ -398,11 +398,11 @@ void QSequentialAnimationGroupJob::animationRemoved(QAbstractAnimationJob *anim,
     bool removingCurrent = anim == m_currentAnimation;
     if (removingCurrent) {
         if (next)
-            setCurrentAnimation(next); //let's try to take the next one
+            RETURN_IF_DELETED(setCurrentAnimation(next)); //let's try to take the next one
         else if (prev)
-            setCurrentAnimation(prev);
+            RETURN_IF_DELETED(setCurrentAnimation(prev));
         else// case all animations were removed
-            setCurrentAnimation(nullptr);
+            RETURN_IF_DELETED(setCurrentAnimation(nullptr));
     }
 
     // duration of the previous animations up to the current animation
diff --git a/src/qml/common/qqmljsfixedpoolarray_p.h b/src/qml/common/qqmljsfixedpoolarray_p.h
index b65b994d6c..15a8cd6878 100644
--- a/src/qml/common/qqmljsfixedpoolarray_p.h
+++ b/src/qml/common/qqmljsfixedpoolarray_p.h
@@ -86,7 +86,7 @@ public:
         if (QTypeInfo<T>::isComplex) {
             for (int i = 0; i < count; ++i)
                 new (data + i) T(vector.at(i));
-        } else {
+        } else if (count) {
             memcpy(data, static_cast<const void*>(vector.constData()), count * sizeof(T));
         }
     }
diff --git a/src/qml/doc/src/cppintegration/definetypes.qdoc b/src/qml/doc/src/cppintegration/definetypes.qdoc
index cbbbd9ba58..ece2fd5fd7 100644
--- a/src/qml/doc/src/cppintegration/definetypes.qdoc
+++ b/src/qml/doc/src/cppintegration/definetypes.qdoc
@@ -117,6 +117,14 @@ QML_IMPORT_NAME = com.mycompany.messaging
 QML_IMPORT_MAJOR_VERSION = 1
 \endcode
 
+If the header the class is declared in is not accessible from your project's
+include path, you may have to amend the include path so that the generated
+registration code can be compiled:
+
+\code
+INCLUDEPATH += com/mycompany/messaging
+\endcode
+
 The type can be used in an \l{qtqml-syntax-basics.html#object-declarations}
 {object declaration} from QML, and its properties can be read and written to,
 as per the example below:
diff --git a/src/qml/doc/src/qmlfunctions.qdoc b/src/qml/doc/src/qmlfunctions.qdoc
index 12b7efb159..4e531ceb61 100644
--- a/src/qml/doc/src/qmlfunctions.qdoc
+++ b/src/qml/doc/src/qmlfunctions.qdoc
@@ -250,6 +250,10 @@
   This is useful for registering types that cannot be amended to add the macros,
   for example because they belong to 3rdparty libraries.
 
+  \b{NOTE:} You may want to use \l QML_NAMED_ELEMENT() instead of \l QML_ELEMENT due to the fact that
+  the element will be named like the struct it is contained in, not the foreign type.
+  See \l {Extending QML - Extension Objects Example} for an example.
+
   \sa QML_ELEMENT, QML_NAMED_ELEMENT()
 */
 
diff --git a/src/qml/doc/src/qmllanguageref/modules/qqmlextensionplugin.qdocinc b/src/qml/doc/src/qmllanguageref/modules/qqmlextensionplugin.qdocinc
index ec888ae937..b1fce12dc3 100644
--- a/src/qml/doc/src/qmllanguageref/modules/qqmlextensionplugin.qdocinc
+++ b/src/qml/doc/src/qmllanguageref/modules/qqmlextensionplugin.qdocinc
@@ -33,7 +33,7 @@ called "my.module", you would add the forward declaration in global scope:
 
 \code
 void qml_register_types_my_module();
-\code
+\endcode
 
 Then add the following snippet of code in the implementation of any function
 that's part of the same binary as the registration:
@@ -41,7 +41,7 @@ that's part of the same binary as the registration:
 \code
 volatile auto registration = &qml_register_types_my_module;
 Q_UNUSED(registration);
-\code
+\endcode
 
 \section1 TimeExample QML extension plugin
 
diff --git a/src/qml/jit/qv4assemblercommon.cpp b/src/qml/jit/qv4assemblercommon.cpp
index cc8af723b2..95070fbb96 100644
--- a/src/qml/jit/qv4assemblercommon.cpp
+++ b/src/qml/jit/qv4assemblercommon.cpp
@@ -159,7 +159,8 @@ void PlatformAssemblerCommon::link(Function *function, const char *jitKind)
 
     generateFunctionTable(function, &codeRef);
 
-    linkBuffer.makeExecutable();
+    if (Q_UNLIKELY(!linkBuffer.makeExecutable()))
+        function->jittedCode = nullptr; // The function is not executable, but the coderef exists.
 }
 
 void PlatformAssemblerCommon::prepareCallWithArgCount(int argc)
diff --git a/src/qml/jsapi/qjsvalue.h b/src/qml/jsapi/qjsvalue.h
index 2f95e0ff31..80641ff235 100644
--- a/src/qml/jsapi/qjsvalue.h
+++ b/src/qml/jsapi/qjsvalue.h
@@ -57,7 +57,6 @@ class QDateTime;
 typedef QList<QJSValue> QJSValueList;
 namespace QV4 {
     struct ExecutionEngine;
-    struct Value;
 }
 
 class Q_QML_EXPORT QJSValue
diff --git a/src/qml/jsruntime/qv4arrayobject.cpp b/src/qml/jsruntime/qv4arrayobject.cpp
index df9f117d04..03e5c29973 100644
--- a/src/qml/jsruntime/qv4arrayobject.cpp
+++ b/src/qml/jsruntime/qv4arrayobject.cpp
@@ -254,6 +254,7 @@ ReturnedValue ArrayPrototype::method_from(const FunctionObject *builtin, const V
             }
 
             if (mapfn) {
+                Q_ASSERT(mapArguments); // if mapfn is set, we always setup mapArguments with scope.alloc
                 mapArguments[0] = *nextValue;
                 mapArguments[1] = Value::fromDouble(k);
                 mappedValue = mapfn->call(thisArg, mapArguments, 2);
@@ -297,6 +298,7 @@ ReturnedValue ArrayPrototype::method_from(const FunctionObject *builtin, const V
             CHECK_EXCEPTION();
 
             if (mapfn) {
+                Q_ASSERT(mapArguments); // if mapfn is set, we always setup mapArguments with scope.alloc
                 mapArguments[0] = kValue;
                 mapArguments[1] = Value::fromDouble(k);
                 mappedValue = mapfn->call(thisArg, mapArguments, 2);
diff --git a/src/qml/jsruntime/qv4compilationunitmapper.cpp b/src/qml/jsruntime/qv4compilationunitmapper.cpp
index 74f34a284d..86bcf229d1 100644
--- a/src/qml/jsruntime/qv4compilationunitmapper.cpp
+++ b/src/qml/jsruntime/qv4compilationunitmapper.cpp
@@ -40,23 +40,69 @@
 #include "qv4compilationunitmapper_p.h"
 
 #include <private/qv4compileddata_p.h>
-#include <QFileInfo>
-#include <QDateTime>
-#include <QCoreApplication>
+#include <private/qv4executablecompilationunit_p.h>
+
+#include <QtCore/qdatetime.h>
+#include <QtCore/qmutex.h>
+#include <QtCore/qhash.h>
 
 QT_BEGIN_NAMESPACE
 
 using namespace QV4;
 
-CompilationUnitMapper::CompilationUnitMapper()
-    : dataPtr(nullptr)
+class StaticUnitCache
 {
+public:
+    StaticUnitCache() : m_lock(&s_mutex) {}
 
-}
+    CompilationUnitMapper get(const QString &file)
+    {
+        const auto it = s_staticUnits.constFind(file);
+        return it == s_staticUnits.constEnd() ? CompilationUnitMapper() : *it;
+    }
+
+    void set(const QString &file, const CompilationUnitMapper &staticUnit) {
+        s_staticUnits.insert(file, staticUnit);
+    }
+
+private:
+    QMutexLocker m_lock;
+
+    static QMutex s_mutex;
+
+    // We can copy the mappers around because they're all static, that is the dtors are noops.
+    static QHash<QString, CompilationUnitMapper> s_staticUnits;
+};
+
+QHash<QString, CompilationUnitMapper> StaticUnitCache::s_staticUnits;
+QMutex StaticUnitCache::s_mutex;
 
 CompilationUnitMapper::~CompilationUnitMapper()
 {
     close();
 }
 
+CompiledData::Unit *CompilationUnitMapper::get(
+        const QString &cacheFilePath, const QDateTime &sourceTimeStamp, QString *errorString)
+{
+    StaticUnitCache cache;
+
+    CompilationUnitMapper mapper = cache.get(cacheFilePath);
+    if (mapper.dataPtr) {
+        auto *unit = reinterpret_cast<CompiledData::Unit *>(mapper.dataPtr);
+        if (ExecutableCompilationUnit::verifyHeader(unit, sourceTimeStamp, errorString)) {
+            *this = mapper;
+            return unit;
+        }
+
+        return nullptr;
+    }
+
+    CompiledData::Unit *data = open(cacheFilePath, sourceTimeStamp, errorString);
+    if (data && (data->flags & CompiledData::Unit::StaticData))
+        cache.set(cacheFilePath, *this);
+
+    return data;
+}
+
 QT_END_NAMESPACE
diff --git a/src/qml/jsruntime/qv4compilationunitmapper_p.h b/src/qml/jsruntime/qv4compilationunitmapper_p.h
index 80f914c141..10ad0a6ede 100644
--- a/src/qml/jsruntime/qv4compilationunitmapper_p.h
+++ b/src/qml/jsruntime/qv4compilationunitmapper_p.h
@@ -65,17 +65,20 @@ struct Unit;
 class CompilationUnitMapper
 {
 public:
-    CompilationUnitMapper();
     ~CompilationUnitMapper();
 
-    CompiledData::Unit *open(const QString &cacheFilePath, const QDateTime &sourceTimeStamp, QString *errorString);
-    void close();
+    CompiledData::Unit *get(
+            const QString &cacheFilePath, const QDateTime &sourceTimeStamp, QString *errorString);
 
 private:
+    CompiledData::Unit *open(
+            const QString &cacheFilePath, const QDateTime &sourceTimeStamp, QString *errorString);
+    void close();
+
 #if defined(Q_OS_UNIX)
-    size_t length;
+    size_t length = 0;
 #endif
-    void *dataPtr;
+    void *dataPtr = nullptr;
 };
 
 }
diff --git a/src/qml/jsruntime/qv4executableallocator.cpp b/src/qml/jsruntime/qv4executableallocator.cpp
index 7ee6f39aa2..c06773d3c5 100644
--- a/src/qml/jsruntime/qv4executableallocator.cpp
+++ b/src/qml/jsruntime/qv4executableallocator.cpp
@@ -45,12 +45,22 @@
 
 using namespace QV4;
 
-void *ExecutableAllocator::Allocation::exceptionHandler() const
+void *ExecutableAllocator::Allocation::exceptionHandlerStart() const
 {
     return reinterpret_cast<void*>(addr);
 }
 
-void *ExecutableAllocator::Allocation::start() const
+size_t ExecutableAllocator::Allocation::exceptionHandlerSize() const
+{
+    return QV4::exceptionHandlerSize();
+}
+
+void *ExecutableAllocator::Allocation::memoryStart() const
+{
+    return reinterpret_cast<void*>(addr);
+}
+
+void *ExecutableAllocator::Allocation::codeStart() const
 {
     return reinterpret_cast<void*>(addr + exceptionHandlerSize());
 }
diff --git a/src/qml/jsruntime/qv4executableallocator_p.h b/src/qml/jsruntime/qv4executableallocator_p.h
index f98f2c7d33..4735fb151f 100644
--- a/src/qml/jsruntime/qv4executableallocator_p.h
+++ b/src/qml/jsruntime/qv4executableallocator_p.h
@@ -86,8 +86,14 @@ public:
             , free(true)
         {}
 
-        void *exceptionHandler() const;
-        void *start() const;
+        void *memoryStart() const;
+        size_t memorySize() const { return size; }
+
+        void *exceptionHandlerStart() const;
+        size_t exceptionHandlerSize() const;
+
+        void *codeStart() const;
+
         void invalidate() { addr = 0; }
         bool isValid() const { return addr != 0; }
         void deallocate(ExecutableAllocator *allocator);
diff --git a/src/qml/jsruntime/qv4executablecompilationunit.cpp b/src/qml/jsruntime/qv4executablecompilationunit.cpp
index 29e1c6dbf7..2c54388100 100644
--- a/src/qml/jsruntime/qv4executablecompilationunit.cpp
+++ b/src/qml/jsruntime/qv4executablecompilationunit.cpp
@@ -751,7 +751,7 @@ bool ExecutableCompilationUnit::loadFromDisk(const QUrl &url, const QDateTime &s
 
     const QStringList cachePaths = { sourcePath + QLatin1Char('c'), localCacheFilePath(url) };
     for (const QString &cachePath : cachePaths) {
-        CompiledData::Unit *mappedUnit = cacheFile->open(cachePath, sourceTimeStamp, errorString);
+        CompiledData::Unit *mappedUnit = cacheFile->get(cachePath, sourceTimeStamp, errorString);
         if (!mappedUnit)
             continue;
 
diff --git a/src/qml/jsruntime/qv4functiontable_win64.cpp b/src/qml/jsruntime/qv4functiontable_win64.cpp
index fc13dc2602..0cb98641cd 100644
--- a/src/qml/jsruntime/qv4functiontable_win64.cpp
+++ b/src/qml/jsruntime/qv4functiontable_win64.cpp
@@ -106,7 +106,7 @@ struct ExceptionHandlerRecord
 void generateFunctionTable(Function *, JSC::MacroAssemblerCodeRef *codeRef)
 {
     ExceptionHandlerRecord *record = reinterpret_cast<ExceptionHandlerRecord *>(
-                codeRef->executableMemory()->exceptionHandler());
+                codeRef->executableMemory()->exceptionHandlerStart());
 
     record->info.Version             = 1;
     record->info.Flags               = 0;
@@ -136,7 +136,7 @@ void generateFunctionTable(Function *, JSC::MacroAssemblerCodeRef *codeRef)
 void destroyFunctionTable(Function *, JSC::MacroAssemblerCodeRef *codeRef)
 {
     ExceptionHandlerRecord *record = reinterpret_cast<ExceptionHandlerRecord *>(
-                codeRef->executableMemory()->exceptionHandler());
+                codeRef->executableMemory()->exceptionHandlerStart());
     if (!RtlDeleteFunctionTable(&record->handler)) {
         const unsigned int errorCode = GetLastError();
         qWarning() << "Failed to remove win64 unwind hook. Error code:" << errorCode;
diff --git a/src/qml/jsruntime/qv4generatorobject.cpp b/src/qml/jsruntime/qv4generatorobject.cpp
index 4eee6f4338..5077bf1d2b 100644
--- a/src/qml/jsruntime/qv4generatorobject.cpp
+++ b/src/qml/jsruntime/qv4generatorobject.cpp
@@ -97,24 +97,21 @@ ReturnedValue GeneratorFunction::virtualCall(const FunctionObject *f, const Valu
     Function *function = gf->function();
     ExecutionEngine *engine = gf->engine();
 
-    // We need to set up a separate stack for the generator, as it's being re-entered
-    uint stackSize = argc // space for the original arguments
-                   + CppStackFrame::requiredJSStackFrameSize(function); // space for the JS stack frame
-
-    size_t requiredMemory = sizeof(GeneratorObject::Data) - sizeof(Value) + sizeof(Value) * stackSize;
-
     Scope scope(gf);
-    Scoped<GeneratorObject> g(scope, scope.engine->memoryManager->allocManaged<GeneratorObject>(requiredMemory, scope.engine->classes[EngineBase::Class_GeneratorObject]));
+    Scoped<GeneratorObject> g(scope, engine->memoryManager->allocManaged<GeneratorObject>(sizeof(GeneratorObject::Data), engine->classes[EngineBase::Class_GeneratorObject]));
     g->setPrototypeOf(ScopedObject(scope, gf->get(scope.engine->id_prototype())));
 
+    // We need to set up a separate JSFrame for the generator, as it's being re-entered
     Heap::GeneratorObject *gp = g->d();
-    gp->stack.size = stackSize;
-    gp->stack.alloc = stackSize;
+    gp->values.set(engine, engine->newArrayObject(argc));
+    gp->jsFrame.set(engine, engine->newArrayObject(CppStackFrame::requiredJSStackFrameSize(function)));
 
     // copy original arguments
-    memcpy(gp->stack.values, argv, argc*sizeof(Value));
-    gp->cppFrame.init(engine, function, gp->stack.values, argc);
-    gp->cppFrame.setupJSFrame(&gp->stack.values[argc], *gf, gf->scope(),
+    for (int i = 0; i < argc; i++)
+        gp->values->arrayData->setArrayData(engine, i, argv[i]);
+
+    gp->cppFrame.init(engine, function, gp->values->arrayData->values.values, argc);
+    gp->cppFrame.setupJSFrame(gp->jsFrame->arrayData->values.values, *gf, gf->scope(),
                               thisObject ? *thisObject : Value::undefinedValue(),
                               Value::undefinedValue());
 
diff --git a/src/qml/jsruntime/qv4generatorobject_p.h b/src/qml/jsruntime/qv4generatorobject_p.h
index 366319723d..10eea5e46b 100644
--- a/src/qml/jsruntime/qv4generatorobject_p.h
+++ b/src/qml/jsruntime/qv4generatorobject_p.h
@@ -90,7 +90,8 @@ struct GeneratorPrototype : FunctionObject {
     Member(class, Pointer, GeneratorFunction *, function) \
     Member(class, NoMark, GeneratorState, state) \
     Member(class, NoMark, CppStackFrame, cppFrame) \
-    Member(class, ValueArray, ValueArray, stack)
+    Member(class, Pointer, ArrayObject *, values) \
+    Member(class, Pointer, ArrayObject *, jsFrame)
 
 DECLARE_HEAP_OBJECT(GeneratorObject, Object) {
     DECLARE_MARKOBJECTS(GeneratorObject);
diff --git a/src/qml/jsruntime/qv4global_p.h b/src/qml/jsruntime/qv4global_p.h
index c6a737b467..1cd2ecffa4 100644
--- a/src/qml/jsruntime/qv4global_p.h
+++ b/src/qml/jsruntime/qv4global_p.h
@@ -64,21 +64,6 @@
 #include <qtqmlglobal.h>
 #include <private/qtqmlglobal_p.h>
 
-#if defined(Q_CC_MSVC)
-#include <float.h>
-#include <math.h>
-
-namespace std {
-
-inline bool isinf(double d) { return !_finite(d) && !_isnan(d); }
-inline bool isnan(double d) { return !!_isnan(d); }
-inline bool isfinite(double d) { return _finite(d); }
-
-} // namespace std
-
-inline double trunc(double d) { return d > 0 ? floor(d) : ceil(d); }
-#endif
-
 // Do certain things depending on whether the JIT is enabled or disabled
 
 #if QT_CONFIG(qml_jit)
diff --git a/src/qml/jsruntime/qv4mathobject.cpp b/src/qml/jsruntime/qv4mathobject.cpp
index 07440047d4..c6b74e7aba 100644
--- a/src/qml/jsruntime/qv4mathobject.cpp
+++ b/src/qml/jsruntime/qv4mathobject.cpp
@@ -47,7 +47,6 @@
 #include <QtCore/private/qnumeric_p.h>
 #include <QtCore/qthreadstorage.h>
 
-#include <math.h>
 #include <cmath>
 
 using namespace QV4;
diff --git a/src/qml/jsruntime/qv4proxy.cpp b/src/qml/jsruntime/qv4proxy.cpp
index 24676ffd00..8bfc9fc3ba 100644
--- a/src/qml/jsruntime/qv4proxy.cpp
+++ b/src/qml/jsruntime/qv4proxy.cpp
@@ -265,9 +265,9 @@ PropertyAttributes ProxyObject::virtualGetOwnProperty(const Managed *m, Property
     ScopedProperty targetDesc(scope);
     PropertyAttributes targetAttributes = target->getOwnProperty(id, targetDesc);
     if (trapResult->isUndefined()) {
-        p->value = Encode::undefined();
-        if (targetAttributes == Attr_Invalid) {
+        if (p)
             p->value = Encode::undefined();
+        if (targetAttributes == Attr_Invalid) {
             return Attr_Invalid;
         }
         if (!targetAttributes.isConfigurable() || !target->isExtensible()) {
@@ -295,8 +295,10 @@ PropertyAttributes ProxyObject::virtualGetOwnProperty(const Managed *m, Property
         }
     }
 
-    p->value = resultDesc->value;
-    p->set = resultDesc->set;
+    if (p) {
+        p->value = resultDesc->value;
+        p->set = resultDesc->set;
+    }
     return resultAttributes;
 }
 
@@ -622,8 +624,10 @@ OwnPropertyKeyIterator *ProxyObject::virtualOwnPropertyKeys(const Object *m, Val
         else
             targetNonConfigurableKeys->push_back(keyAsValue);
     }
-    if (target->isExtensible() && targetNonConfigurableKeys->getLength() == 0)
+    if (target->isExtensible() && targetNonConfigurableKeys->getLength() == 0) {
+        *iteratorTarget = *m;
         return new ProxyObjectOwnPropertyKeyIterator(trapKeys);
+    }
 
     ScopedArrayObject uncheckedResultKeys(scope, scope.engine->newArrayObject());
     uncheckedResultKeys->copyArrayData(trapKeys);
@@ -637,8 +641,10 @@ OwnPropertyKeyIterator *ProxyObject::virtualOwnPropertyKeys(const Object *m, Val
         }
     }
 
-    if (target->isExtensible())
+    if (target->isExtensible()) {
+        *iteratorTarget = *m;
         return new ProxyObjectOwnPropertyKeyIterator(trapKeys);
+    }
 
     len = targetConfigurableKeys->getLength();
     for (uint i = 0; i < len; ++i) {
diff --git a/src/qml/jsruntime/qv4qmlcontext.cpp b/src/qml/jsruntime/qv4qmlcontext.cpp
index e2d3b98ff6..6eece147a6 100644
--- a/src/qml/jsruntime/qv4qmlcontext.cpp
+++ b/src/qml/jsruntime/qv4qmlcontext.cpp
@@ -466,9 +466,9 @@ ReturnedValue QQmlContextWrapper::resolveQmlContextPropertyLookupGetter(Lookup *
                 return static_cast<Heap::CallContext *>(ctx)->locals[index].asReturnedValue();
         }
 
-        // Skip only block contexts within the current call context.
+        // Skip only block and call contexts.
         // Other contexts need a regular QML property lookup. See below.
-        if (ctx->type != Heap::ExecutionContext::Type_BlockContext)
+        if (ctx->type != Heap::ExecutionContext::Type_BlockContext && ctx->type != Heap::ExecutionContext::Type_CallContext)
             break;
     }
 
diff --git a/src/qml/jsruntime/qv4qobjectwrapper.cpp b/src/qml/jsruntime/qv4qobjectwrapper.cpp
index 9899c9274e..272b85069f 100644
--- a/src/qml/jsruntime/qv4qobjectwrapper.cpp
+++ b/src/qml/jsruntime/qv4qobjectwrapper.cpp
@@ -1160,8 +1160,7 @@ void Heap::QObjectWrapper::markObjects(Heap::Base *that, QV4::MarkStack *markSta
 void QObjectWrapper::destroyObject(bool lastCall)
 {
     Heap::QObjectWrapper *h = d();
-    if (!h->internalClass)
-        return; // destroyObject already got called
+    Q_ASSERT(h->internalClass);
 
     if (h->object()) {
         QQmlData *ddata = QQmlData::get(h->object(), false);
@@ -1191,7 +1190,7 @@ void QObjectWrapper::destroyObject(bool lastCall)
         }
     }
 
-    h->~Data();
+    h->destroy();
 }
 
 
diff --git a/src/qml/jsruntime/qv4stringobject.cpp b/src/qml/jsruntime/qv4stringobject.cpp
index bf098fef26..b5b406b317 100644
--- a/src/qml/jsruntime/qv4stringobject.cpp
+++ b/src/qml/jsruntime/qv4stringobject.cpp
@@ -533,9 +533,9 @@ ReturnedValue StringPrototype::method_lastIndexOf(const FunctionObject *b, const
     if (std::isnan(position))
         position = +qInf();
     else
-        position = trunc(position);
+        position = std::trunc(position);
 
-    int pos = trunc(qMin(qMax(position, 0.0), double(value.length())));
+    int pos = std::trunc(qMin(qMax(position, 0.0), double(value.length())));
     if (!searchString.isEmpty() && pos == value.length())
         --pos;
     if (searchString.isNull() && pos == 0)
diff --git a/src/qml/jsruntime/qv4vme_moth.cpp b/src/qml/jsruntime/qv4vme_moth.cpp
index fb103d492d..d05f48d340 100644
--- a/src/qml/jsruntime/qv4vme_moth.cpp
+++ b/src/qml/jsruntime/qv4vme_moth.cpp
@@ -442,7 +442,10 @@ ReturnedValue VME::exec(CppStackFrame *frame, ExecutionEngine *engine)
 
 #if QT_CONFIG(qml_jit)
     if (debugger == nullptr) {
-        if (function->jittedCode == nullptr) {
+        // Check for codeRef here. In rare cases the JIT compilation may fail, which leaves us
+        // with a (useless) codeRef, but no jittedCode. In that case, don't try to JIT again every
+        // time we execute the function, but just interpret instead.
+        if (function->codeRef == nullptr) {
             if (engine->canJIT(function))
                 QV4::JIT::BaselineJIT(function).generate();
             else
diff --git a/src/qml/memory/qv4mm.cpp b/src/qml/memory/qv4mm.cpp
index 06caf04e5a..da149a67c4 100644
--- a/src/qml/memory/qv4mm.cpp
+++ b/src/qml/memory/qv4mm.cpp
@@ -981,7 +981,7 @@ void MemoryManager::sweep(bool lastSweep, ClassDestroyStatsCallback classCountPt
 
     if (MultiplyWrappedQObjectMap *multiplyWrappedQObjects = engine->m_multiplyWrappedQObjects) {
         for (MultiplyWrappedQObjectMap::Iterator it = multiplyWrappedQObjects->begin(); it != multiplyWrappedQObjects->end();) {
-            if (!it.value().isNullOrUndefined())
+            if (it.value().isNullOrUndefined())
                 it = multiplyWrappedQObjects->erase(it);
             else
                 ++it;
diff --git a/src/qml/qml/qqmlapplicationengine.cpp b/src/qml/qml/qqmlapplicationengine.cpp
index 907825d28c..2b294ffff6 100644
--- a/src/qml/qml/qqmlapplicationengine.cpp
+++ b/src/qml/qml/qqmlapplicationengine.cpp
@@ -146,6 +146,14 @@ void QQmlApplicationEnginePrivate::finishLoad(QQmlComponent *c)
         break;
     case QQmlComponent::Ready: {
         auto newObj = initialProperties.empty() ? c->create() : c->createWithInitialProperties(initialProperties);
+
+        if (c->isError()) {
+           qWarning() << "QQmlApplicationEngine failed to create component";
+           warning(c->errors());
+           q->objectCreated(nullptr, c->url());
+           break;
+        }
+
         objects << newObj;
         QObject::connect(newObj, &QObject::destroyed, q, [&](QObject *obj) { objects.removeAll(obj); });
         q->objectCreated(objects.constLast(), c->url());
diff --git a/src/qml/qml/qqmlextensionplugin.h b/src/qml/qml/qqmlextensionplugin.h
index ef7ff422cd..afb3f99c4a 100644
--- a/src/qml/qml/qqmlextensionplugin.h
+++ b/src/qml/qml/qqmlextensionplugin.h
@@ -44,6 +44,13 @@
 #include <QtCore/QUrl>
 #include <QtQml/qqmlextensioninterface.h>
 
+#if defined(Q_CC_GHS)
+#  define GHS_PRAGMA(S) _Pragma(#S)
+#  define GHS_KEEP_REFERENCE(S) GHS_PRAGMA(ghs reference S ##__Fv)
+#else
+#  define GHS_KEEP_REFERENCE(S)
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QQmlEngine;
diff --git a/src/qml/qml/qqmlimport.cpp b/src/qml/qml/qqmlimport.cpp
index 6d4fba0aa4..10c6c41338 100644
--- a/src/qml/qml/qqmlimport.cpp
+++ b/src/qml/qml/qqmlimport.cpp
@@ -730,7 +730,8 @@ bool QQmlImportInstance::resolveType(QQmlTypeLoader *typeLoader, const QHashedSt
             if (containingType.isValid()) {
                 // we currently cannot reference a Singleton inside itself
                 // in that case, containingType is still invalid
-                if (int icID = containingType.lookupInlineComponentIdByName(typeStr) != -1) {
+                int icID = containingType.lookupInlineComponentIdByName(typeStr);
+                if (icID != -1) {
                     *type_return = containingType.lookupInlineComponentById(icID);
                 } else {
                     auto icType = createICType();
@@ -1408,11 +1409,16 @@ QQmlImports::LocalQmldirResult QQmlImportsPrivate::locateLocalQmldir(
         if (!absoluteFilePath.isEmpty()) {
             QString url;
             const QStringRef absolutePath = absoluteFilePath.leftRef(absoluteFilePath.lastIndexOf(Slash) + 1);
-            if (absolutePath.at(0) == Colon)
+            if (absolutePath.at(0) == Colon) {
                 url = QLatin1String("qrc") + absolutePath;
-            else
+            } else {
                 url = QUrl::fromLocalFile(absolutePath.toString()).toString();
-
+                // This handles the UNC path case as when the path is retrieved from the QUrl it
+                // will convert the host name from upper case to lower case. So the absoluteFilePath
+                // is changed at this point to make sure it will match later on in that case.
+                if (absoluteFilePath.startsWith(QLatin1String("//")))
+                    absoluteFilePath = QUrl::fromLocalFile(absoluteFilePath).toString(QUrl::RemoveScheme);
+            }
             QQmlImportDatabase::QmldirCache *cache = new QQmlImportDatabase::QmldirCache;
             cache->versionMajor = vmaj;
             cache->versionMinor = vmin;
diff --git a/src/qml/qml/qqmlincubator.cpp b/src/qml/qml/qqmlincubator.cpp
index 0ad013e90b..244f9ad292 100644
--- a/src/qml/qml/qqmlincubator.cpp
+++ b/src/qml/qml/qqmlincubator.cpp
@@ -330,7 +330,7 @@ void QQmlIncubatorPrivate::incubate(QQmlInstantiationInterrupt &i)
             ddata->rootObjectInCreation = false;
             if (q) {
                 q->setInitialState(result);
-                if (!creator->requiredProperties().empty()) {
+                if (creator && !creator->requiredProperties().empty()) {
                     const auto& unsetRequiredProperties = creator->requiredProperties();
                     for (const auto& unsetRequiredProperty: unsetRequiredProperties)
                         errors << QQmlComponentPrivate::unsetRequiredPropertyToQQmlError(unsetRequiredProperty);
diff --git a/src/qml/qml/qqmlirloader.cpp b/src/qml/qml/qqmlirloader.cpp
index 5609ba8aa8..7fa3d211a6 100644
--- a/src/qml/qml/qqmlirloader.cpp
+++ b/src/qml/qml/qqmlirloader.cpp
@@ -208,6 +208,13 @@ QmlIR::Object *QQmlIRLoader::loadObject(const QV4::CompiledData::Object *seriali
         object->inlineComponents->append(ic);
     }
 
+    const QV4::CompiledData::RequiredPropertyExtraData *serializedRequiredPropertyExtraData = serializedObject->requiredPropertyExtraDataTable();
+    for (uint i = 0u; i < serializedObject->nRequiredPropertyExtraData; ++i, ++serializedRequiredPropertyExtraData) {
+        QmlIR::RequiredPropertyExtraData *extra = pool->New<QmlIR::RequiredPropertyExtraData>();
+        *static_cast<QV4::CompiledData::RequiredPropertyExtraData *>(extra) = *serializedRequiredPropertyExtraData;
+        object->requiredPropertyExtraDatas->append(extra);
+    }
+
     return object;
 }
 
diff --git a/src/qml/qml/qqmllocale.cpp b/src/qml/qml/qqmllocale.cpp
index 7af6af276a..f55bbe7ffc 100644
--- a/src/qml/qml/qqmllocale.cpp
+++ b/src/qml/qml/qqmllocale.cpp
@@ -891,7 +891,7 @@ ReturnedValue QQmlLocale::method_localeCompare(const QV4::FunctionObject *b, con
 */
 
 /*!
-    \qmlproperty enumeration QtQml::Locale::NumberOption
+    \qmlproperty enumeration QtQml::Locale::numberOptions
 
     Holds a set of options for number-to-string and
     string-to-number conversions.
diff --git a/src/qml/qml/qqmlmetatype.cpp b/src/qml/qml/qqmlmetatype.cpp
index be4a79297c..40300b1fe3 100644
--- a/src/qml/qml/qqmlmetatype.cpp
+++ b/src/qml/qml/qqmlmetatype.cpp
@@ -1260,6 +1260,16 @@ void QQmlMetaType::unregisterType(int typeIndex)
     }
 }
 
+static bool hasActiveInlineComponents(const QQmlTypePrivate *d)
+{
+    for (const QQmlType &ic : qAsConst(d->objectIdToICType)) {
+        const QQmlTypePrivate *icPriv = ic.priv();
+        if (icPriv && icPriv->count() > 1)
+            return true;
+    }
+    return false;
+}
+
 void QQmlMetaType::freeUnusedTypesAndCaches()
 {
     QQmlMetaTypeDataPtr data;
@@ -1274,7 +1284,7 @@ void QQmlMetaType::freeUnusedTypesAndCaches()
         QList<QQmlType>::Iterator it = data->types.begin();
         while (it != data->types.end()) {
             const QQmlTypePrivate *d = (*it).priv();
-            if (d && d->count() == 1) {
+            if (d && d->count() == 1 && !hasActiveInlineComponents(d)) {
                 deletedAtLeastOneType = true;
 
                 removeQQmlTypePrivate(data->idToType, d);
diff --git a/src/qml/qml/qqmlobjectcreator.cpp b/src/qml/qml/qqmlobjectcreator.cpp
index 1c8f2b2091..6aeb567a86 100644
--- a/src/qml/qml/qqmlobjectcreator.cpp
+++ b/src/qml/qml/qqmlobjectcreator.cpp
@@ -679,8 +679,7 @@ void QQmlObjectCreator::setPropertyValue(const QQmlPropertyData *property, const
         // otherwise, try a custom type assignment
         QString stringValue = compilationUnit->bindingValueAsString(binding);
         QQmlMetaType::StringConverter converter = QQmlMetaType::customStringConverter(property->propType());
-        Q_ASSERT(converter);
-        QVariant value = (*converter)(stringValue);
+        QVariant value = converter ? (*converter)(stringValue) : QVariant();
 
         QMetaProperty metaProperty = _qobject->metaObject()->property(property->coreIndex());
         if (value.isNull() || metaProperty.userType() != property->propType()) {
diff --git a/src/qml/qml/qqmlproperty.cpp b/src/qml/qml/qqmlproperty.cpp
index 8521de6ab3..9eb81e566e 100644
--- a/src/qml/qml/qqmlproperty.cpp
+++ b/src/qml/qml/qqmlproperty.cpp
@@ -918,6 +918,8 @@ QQmlPropertyPrivate::signalExpression(const QQmlProperty &that)
     if (!(that.type() & QQmlProperty::SignalProperty))
         return nullptr;
 
+    if (!that.d->object)
+        return nullptr;
     QQmlData *data = QQmlData::get(that.d->object);
     if (!data)
         return nullptr;
@@ -957,6 +959,8 @@ void QQmlPropertyPrivate::takeSignalExpression(const QQmlProperty &that,
         return;
     }
 
+    if (!that.d->object)
+        return;
     QQmlData *data = QQmlData::get(that.d->object, nullptr != expr);
     if (!data)
         return;
diff --git a/src/qml/qml/qqmlproperty_p.h b/src/qml/qml/qqmlproperty_p.h
index 8abd83d7b4..b76a216cf3 100644
--- a/src/qml/qml/qqmlproperty_p.h
+++ b/src/qml/qml/qqmlproperty_p.h
@@ -71,7 +71,7 @@ class QQmlMetaObject;
 class Q_QML_PRIVATE_EXPORT QQmlPropertyPrivate : public QQmlRefCount
 {
 public:
-    QQmlContextData *context;
+    QQmlGuardedContextData context;
     QPointer<QQmlEngine> engine;
     QPointer<QObject> object;
 
diff --git a/src/qml/qml/qqmlpropertycachecreator.cpp b/src/qml/qml/qqmlpropertycachecreator.cpp
index 36581bda4e..88d80d88ab 100644
--- a/src/qml/qml/qqmlpropertycachecreator.cpp
+++ b/src/qml/qml/qqmlpropertycachecreator.cpp
@@ -90,6 +90,15 @@ QByteArray QQmlPropertyCacheCreatorBase::createClassNameTypeByUrl(const QUrl &ur
             QByteArray::number(classIndexCounter.fetchAndAddRelaxed(1));
 }
 
+QByteArray QQmlPropertyCacheCreatorBase::createClassNameForInlineComponent(const QUrl &baseUrl, int icId)
+{
+    QByteArray baseName = createClassNameTypeByUrl(baseUrl);
+    if (baseName.isEmpty())
+        baseName = QByteArray("ANON_QML_IC_") + QByteArray::number(classIndexCounter.fetchAndAddRelaxed(1));
+    baseName += "_" + QByteArray::number(icId);
+    return baseName;
+}
+
 QQmlBindingInstantiationContext::QQmlBindingInstantiationContext(int referencingObjectIndex, const QV4::CompiledData::Binding *instantiatingBinding,
                                                                  const QString &instantiatingPropertyName, QQmlPropertyCache *referencingObjectPropertyCache)
     : referencingObjectIndex(referencingObjectIndex)
diff --git a/src/qml/qml/qqmlpropertycachecreator_p.h b/src/qml/qml/qqmlpropertycachecreator_p.h
index 6b02d6fb98..77e3763a49 100644
--- a/src/qml/qml/qqmlpropertycachecreator_p.h
+++ b/src/qml/qml/qqmlpropertycachecreator_p.h
@@ -104,6 +104,8 @@ public:
     static int metaTypeForPropertyType(QV4::CompiledData::BuiltinType type);
 
     static QByteArray createClassNameTypeByUrl(const QUrl &url);
+
+    static QByteArray createClassNameForInlineComponent(const QUrl &baseUrl, int icId);
 };
 
 template <typename ObjectContainer>
diff --git a/src/qml/qml/qqmlpropertyvalidator.cpp b/src/qml/qml/qqmlpropertyvalidator.cpp
index 3587609301..3a1f33113f 100644
--- a/src/qml/qml/qqmlpropertyvalidator.cpp
+++ b/src/qml/qml/qqmlpropertyvalidator.cpp
@@ -651,6 +651,19 @@ bool QQmlPropertyValidator::canCoerce(int to, QQmlPropertyCache *fromMo) const
 {
     QQmlPropertyCache *toMo = enginePrivate->rawPropertyCacheForType(to);
 
+    if (toMo == nullptr) {
+        // if we have an inline component from the current file,
+        // it is not properly registered at this point, as registration
+        // only occurs after the whole file has been validated
+        // Therefore we need to check the ICs here
+        for (const auto& icDatum : compilationUnit->inlineComponentData) {
+            if (icDatum.typeIds.id == to) {
+                toMo = compilationUnit->propertyCaches.at(icDatum.objectIndex);
+                break;
+            }
+        }
+    }
+
     while (fromMo) {
         if (fromMo == toMo)
             return true;
@@ -746,6 +759,18 @@ QQmlError QQmlPropertyValidator::validateObjectBinding(QQmlPropertyData *propert
         // effect the properties on the type, but don't effect assignability
         // Using -1 for the minor version ensures that we get the raw metaObject.
         QQmlPropertyCache *propertyMetaObject = enginePrivate->rawPropertyCacheForType(propType, -1);
+        if (!propertyMetaObject) {
+            // if we have an inline component from the current file,
+            // it is not properly registered at this point, as registration
+            // only occurs after the whole file has been validated
+            // Therefore we need to check the ICs here
+            for (const auto& icDatum: compilationUnit->inlineComponentData) {
+                if (icDatum.typeIds.id == property->propType()) {
+                    propertyMetaObject = compilationUnit->propertyCaches.at(icDatum.objectIndex);
+                    break;
+                }
+            }
+        }
 
         if (propertyMetaObject) {
             // Will be true if the assigned type inherits propertyMetaObject
diff --git a/src/qml/qml/qqmlscriptdata.cpp b/src/qml/qml/qqmlscriptdata.cpp
index ae268ca904..9ef49e9641 100644
--- a/src/qml/qml/qqmlscriptdata.cpp
+++ b/src/qml/qml/qqmlscriptdata.cpp
@@ -113,10 +113,6 @@ QV4::ReturnedValue QQmlScriptData::scriptValueForContext(QQmlContextData *parent
     QV4::ExecutionEngine *v4 = parentQmlContextData->engine->handle();
     QV4::Scope scope(v4);
 
-    if (!hasEngine()) {
-        addToEngine(parentQmlContextData->engine);
-        addref();
-    }
 
     QQmlContextDataRef qmlContextData = qmlContextDataForContext(parentQmlContextData);
     QV4::Scoped<QV4::QmlContext> qmlExecutionContext(scope);
@@ -154,13 +150,4 @@ QV4::ReturnedValue QQmlScriptData::scriptValueForContext(QQmlContextData *parent
     return value->asReturnedValue();
 }
 
-void QQmlScriptData::clear()
-{
-    typeNameCache = nullptr;
-    scripts.clear();
-
-    // An addref() was made when the QQmlCleanup was added to the engine.
-    release();
-}
-
 QT_END_NAMESPACE
diff --git a/src/qml/qml/qqmlscriptdata_p.h b/src/qml/qml/qqmlscriptdata_p.h
index 80b65b699c..0ace1cd376 100644
--- a/src/qml/qml/qqmlscriptdata_p.h
+++ b/src/qml/qml/qqmlscriptdata_p.h
@@ -65,14 +65,7 @@ QT_BEGIN_NAMESPACE
 class QQmlTypeNameCache;
 class QQmlContextData;
 
-// QQmlScriptData instances are created, uninitialized, by the loader in the
-// load thread.  The first time they are used by the VME, they are initialized which
-// creates their v8 objects and they are referenced and added to the  engine's cleanup
-// list.  During QQmlCleanup::clear() all v8 resources are destroyed, and the
-// reference that was created is released but final deletion only occurs once all the
-// references as released.  This is all intended to ensure that the v8 resources are
-// only created and destroyed in the main thread :)
-class Q_AUTOTEST_EXPORT QQmlScriptData : public QQmlCleanup, public QQmlRefCount
+class Q_AUTOTEST_EXPORT QQmlScriptData : public QQmlRefCount
 {
 private:
     friend class QQmlTypeLoader;
@@ -89,13 +82,9 @@ public:
 
     QQmlRefPointer<QV4::ExecutableCompilationUnit> compilationUnit() const { return m_precompiledScript; }
 
-protected:
-    void clear() override; // From QQmlCleanup
-
 private:
     friend class QQmlScriptBlob;
 
-    void initialize(QQmlEngine *);
     QQmlContextData *qmlContextDataForContext(QQmlContextData *parentQmlContextData);
 
     bool m_loaded;
diff --git a/src/qml/qml/qqmltypedata.cpp b/src/qml/qml/qqmltypedata.cpp
index fc1d0cfbcf..92a90ea677 100644
--- a/src/qml/qml/qqmltypedata.cpp
+++ b/src/qml/qml/qqmltypedata.cpp
@@ -283,9 +283,7 @@ void setupICs(const ObjectContainer &container, QHash<int, InlineComponentData>
     for (int i = 0; i != container->objectCount(); ++i) {
         auto root = container->objectAt(i);
         for (auto it = root->inlineComponentsBegin(); it != root->inlineComponentsEnd(); ++it) {
-            auto url = finalUrl;
-            url.setFragment(QString::number(it->objectIndex));
-            const QByteArray &className = QQmlPropertyCacheCreatorBase::createClassNameTypeByUrl(url);
+            const QByteArray &className = QQmlPropertyCacheCreatorBase::createClassNameForInlineComponent(finalUrl, it->objectIndex);
             InlineComponentData icDatum(QQmlMetaType::registerInternalCompositeType(className), int(it->objectIndex), int(it->nameIndex), 0, 0, 0);
             icData->insert(it->objectIndex, icDatum);
         }
diff --git a/src/qml/qtqmlglobal_p.h b/src/qml/qtqmlglobal_p.h
index a729729b67..7b0910fa13 100644
--- a/src/qml/qtqmlglobal_p.h
+++ b/src/qml/qtqmlglobal_p.h
@@ -53,6 +53,7 @@
 
 #include <QtCore/private/qglobal_p.h>
 #include <QtQml/qtqmlglobal.h>
+#include <QtQml/qqmlextensionplugin.h>
 #ifndef QT_QML_BOOTSTRAPPED
 #  include <QtQml/private/qtqml-config_p.h>
 #endif
@@ -61,6 +62,7 @@
 #define Q_QML_PRIVATE_EXPORT Q_QML_EXPORT
 
 void Q_QML_PRIVATE_EXPORT qml_register_types_QtQml();
+GHS_KEEP_REFERENCE(qml_register_types_QtQml);
 
 #if !defined(QT_QMLDEVTOOLS_LIB) && !defined(QT_BUILD_QMLDEVTOOLS_LIB)
 #  define Q_QML_AUTOTEST_EXPORT Q_AUTOTEST_EXPORT
diff --git a/src/qmldebug/qqmlprofilerevent_p.h b/src/qmldebug/qqmlprofilerevent_p.h
index a7e37d1964..01b2f58f16 100644
--- a/src/qmldebug/qqmlprofilerevent_p.h
+++ b/src/qmldebug/qqmlprofilerevent_p.h
@@ -48,6 +48,7 @@
 #include <QtCore/qmetatype.h>
 
 #include <initializer_list>
+#include <limits>
 #include <type_traits>
 
 //
diff --git a/src/qmlmodels/qqmldelegatemodel.cpp b/src/qmlmodels/qqmldelegatemodel.cpp
index 725b9e8bc3..53e511303e 100644
--- a/src/qmlmodels/qqmldelegatemodel.cpp
+++ b/src/qmlmodels/qqmldelegatemodel.cpp
@@ -1,6 +1,6 @@
 /****************************************************************************
 **
-** Copyright (C) 2016 The Qt Company Ltd.
+** Copyright (C) 2020 The Qt Company Ltd.
 ** Contact: https://www.qt.io/licensing/
 **
 ** This file is part of the QtQml module of the Qt Toolkit.
@@ -389,6 +389,12 @@ void QQmlDelegateModelPrivate::connectToAbstractItemModel()
                       q,  QQmlDelegateModel, SLOT(_q_rowsRemoved(QModelIndex,int,int)));
     qmlobject_connect(aim, QAbstractItemModel, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
                       q,  QQmlDelegateModel, SLOT(_q_rowsAboutToBeRemoved(QModelIndex,int,int)));
+    qmlobject_connect(aim, QAbstractItemModel, SIGNAL(columnsInserted(QModelIndex,int,int)),
+                      q, QQmlDelegateModel, SLOT(_q_columnsInserted(QModelIndex,int,int)));
+    qmlobject_connect(aim, QAbstractItemModel, SIGNAL(columnsRemoved(QModelIndex,int,int)),
+                      q, QQmlDelegateModel, SLOT(_q_columnsRemoved(QModelIndex,int,int)));
+    qmlobject_connect(aim, QAbstractItemModel, SIGNAL(columnsMoved(QModelIndex,int,int,QModelIndex,int)),
+                      q, QQmlDelegateModel, SLOT(_q_columnsMoved(QModelIndex,int,int,QModelIndex,int)));
     qmlobject_connect(aim, QAbstractItemModel, SIGNAL(dataChanged(QModelIndex,QModelIndex,QVector<int>)),
                       q, QQmlDelegateModel, SLOT(_q_dataChanged(QModelIndex,QModelIndex,QVector<int>)));
     qmlobject_connect(aim, QAbstractItemModel, SIGNAL(rowsMoved(QModelIndex,int,int,QModelIndex,int)),
@@ -413,6 +419,12 @@ void QQmlDelegateModelPrivate::disconnectFromAbstractItemModel()
                         q, SLOT(_q_rowsAboutToBeRemoved(QModelIndex,int,int)));
     QObject::disconnect(aim, SIGNAL(rowsRemoved(QModelIndex,int,int)),
                         q, SLOT(_q_rowsRemoved(QModelIndex,int,int)));
+    QObject::disconnect(aim, SIGNAL(columnsInserted(QModelIndex,int,int)), q,
+                        SLOT(_q_columnsInserted(QModelIndex,int,int)));
+    QObject::disconnect(aim, SIGNAL(columnsRemoved(QModelIndex,int,int)), q,
+                        SLOT(_q_columnsRemoved(QModelIndex,int,int)));
+    QObject::disconnect(aim, SIGNAL(columnsMoved(QModelIndex,int,int,QModelIndex,int)), q,
+                        SLOT(_q_columnsMoved(QModelIndex,int,int,QModelIndex,int)));
     QObject::disconnect(aim, SIGNAL(dataChanged(QModelIndex,QModelIndex,QVector<int>)),
                         q, SLOT(_q_dataChanged(QModelIndex,QModelIndex,QVector<int>)));
     QObject::disconnect(aim, SIGNAL(rowsMoved(QModelIndex,int,int,QModelIndex,int)),
@@ -1609,7 +1621,7 @@ void QQmlDelegateModelPrivate::itemsRemoved(
         removed[i] = 0;
 
     for (const Compositor::Remove &remove : removes) {
-        for (; cacheIndex < remove.cacheIndex; ++cacheIndex)
+        for (; cacheIndex < remove.cacheIndex && cacheIndex < m_cache.size(); ++cacheIndex)
             incrementIndexes(m_cache.at(cacheIndex), m_groupCount, removed);
 
         for (int i = 1; i < m_groupCount; ++i) {
@@ -1875,6 +1887,9 @@ void QQmlDelegateModel::_q_modelReset()
         d->m_count = d->adaptorModelCount();
 
         const QList<QQmlDelegateModelItem *> cache = d->m_cache;
+        for (QQmlDelegateModelItem *item : cache)
+            item->referenceObject();
+
         for (int i = 0, c = cache.count();  i < c; ++i) {
             QQmlDelegateModelItem *item = cache.at(i);
             // layout change triggered by changing the modelIndex might have
@@ -1886,6 +1901,8 @@ void QQmlDelegateModel::_q_modelReset()
                 item->setModelIndex(-1, -1, -1);
         }
 
+        for (QQmlDelegateModelItem *item : cache)
+            item->releaseObject();
         QVector<Compositor::Remove> removes;
         QVector<Compositor::Insert> inserts;
         if (oldCount)
@@ -1953,6 +1970,38 @@ void QQmlDelegateModel::_q_rowsMoved(
     }
 }
 
+void QQmlDelegateModel::_q_columnsInserted(const QModelIndex &parent, int begin, int end)
+{
+    Q_D(QQmlDelegateModel);
+    Q_UNUSED(end);
+    if (parent == d->m_adaptorModel.rootIndex && begin == 0) {
+        // mark all items as changed
+        _q_itemsChanged(0, d->m_count, QVector<int>());
+    }
+}
+
+void QQmlDelegateModel::_q_columnsRemoved(const QModelIndex &parent, int begin, int end)
+{
+    Q_D(QQmlDelegateModel);
+    Q_UNUSED(end);
+    if (parent == d->m_adaptorModel.rootIndex && begin == 0) {
+        // mark all items as changed
+        _q_itemsChanged(0, d->m_count, QVector<int>());
+    }
+}
+
+void QQmlDelegateModel::_q_columnsMoved(const QModelIndex &parent, int start, int end,
+                                        const QModelIndex &destination, int column)
+{
+    Q_D(QQmlDelegateModel);
+    Q_UNUSED(end);
+    if ((parent == d->m_adaptorModel.rootIndex && start == 0)
+        || (destination == d->m_adaptorModel.rootIndex && column == 0)) {
+        // mark all items as changed
+        _q_itemsChanged(0, d->m_count, QVector<int>());
+    }
+}
+
 void QQmlDelegateModel::_q_dataChanged(const QModelIndex &begin, const QModelIndex &end, const QVector<int> &roles)
 {
     Q_D(QQmlDelegateModel);
@@ -2379,6 +2428,15 @@ void QQmlDelegateModelItem::destroyObject()
         data->ownContext = nullptr;
         data->context = nullptr;
     }
+    /* QTBUG-87228: when destroying object at the application exit, the deferred
+     * parent by setting it to QCoreApplication instance if it's nullptr, so
+     * deletion won't work. Not to leak memory, make sure our object has a that
+     * the parent claims the object at the end of the lifetime. When not at the
+     * application exit, normal event loop will handle the deferred deletion
+     * earlier.
+     */
+    if (object->parent() == nullptr)
+        object->setParent(QCoreApplication::instance());
     object->deleteLater();
 
     if (attached) {
diff --git a/src/qmlmodels/qqmldelegatemodel_p.h b/src/qmlmodels/qqmldelegatemodel_p.h
index 8aab4badca..d140bfbaaf 100644
--- a/src/qmlmodels/qqmldelegatemodel_p.h
+++ b/src/qmlmodels/qqmldelegatemodel_p.h
@@ -152,6 +152,9 @@ private Q_SLOTS:
     void _q_itemsMoved(int from, int to, int count);
     void _q_modelReset();
     void _q_rowsInserted(const QModelIndex &,int,int);
+    void _q_columnsInserted(const QModelIndex &, int, int);
+    void _q_columnsRemoved(const QModelIndex &, int, int);
+    void _q_columnsMoved(const QModelIndex &, int, int, const QModelIndex &, int);
     void _q_rowsAboutToBeRemoved(const QModelIndex &parent, int begin, int end);
     void _q_rowsRemoved(const QModelIndex &,int,int);
     void _q_rowsMoved(const QModelIndex &, int, int, const QModelIndex &, int);
diff --git a/src/qmlmodels/qqmllistmodel.cpp b/src/qmlmodels/qqmllistmodel.cpp
index e07951cab3..e392c9e323 100644
--- a/src/qmlmodels/qqmllistmodel.cpp
+++ b/src/qmlmodels/qqmllistmodel.cpp
@@ -446,7 +446,8 @@ bool ListModel::sync(ListModel *src, ListModel *target)
     // to ensure things are kept in the correct order, emit inserts and moves first. This shouls ensure all persistent
     // model indices are updated correctly
     int rowsInserted = 0;
-    for (int i = 0 ; i < target->elements.count() ; ++i) {
+    const int targetElementCount = target->elements.count();
+    for (int i = 0 ; i < targetElementCount ; ++i) {
         ListElement *element = target->elements.at(i);
         ElementSync &s = elementHash.find(element->getUid()).value();
         Q_ASSERT(s.srcIndex >= 0);
@@ -456,13 +457,33 @@ bool ListModel::sync(ListModel *src, ListModel *target)
                 if (s.targetIndex == -1) {
                     targetModel->beginInsertRows(QModelIndex(), i, i);
                     targetModel->endInsertRows();
+                    ++rowsInserted;
                 } else {
-                    targetModel->beginMoveRows(QModelIndex(), i, i, QModelIndex(), s.srcIndex);
+                    bool validMove = targetModel->beginMoveRows(QModelIndex(), s.targetIndex, s.targetIndex, QModelIndex(), i);
+                    Q_ASSERT(validMove);
+                    Q_UNUSED(validMove); // fixes unused variable warning if asserts are disabled
                     targetModel->endMoveRows();
+                    // fixup target indices of elements that still need to move
+                    for (int j=i+1; j < targetElementCount; ++j) {
+                        ListElement *eToFix = target->elements.at(j);
+                        ElementSync &sToFix = elementHash.find(eToFix->getUid()).value();
+                        if (i < s.targetIndex) {
+                            // element was moved down
+                            if (sToFix.targetIndex > s.targetIndex || sToFix.targetIndex < i)
+                                continue; // unaffected by reordering
+                            else
+                                sToFix.targetIndex += 1;
+                        } else {
+                            // element was moved up
+                            if (sToFix.targetIndex < s.targetIndex || sToFix.targetIndex > i)
+                                continue; // unaffected by reordering
+                            else
+                                sToFix.targetIndex -= 1;
+                        }
+                    }
                 }
             }
             hasChanges = true;
-            ++rowsInserted;
         }
         if (s.targetIndex != -1 && !s.changedRoles.isEmpty()) {
             QModelIndex idx = targetModel->createIndex(i, 0);
@@ -703,7 +724,7 @@ void ListModel::set(int elementIndex, QV4::Object *object, ListModel::SetElement
         } else if (propertyValue->isNullOrUndefined()) {
             if (reason == SetElement::WasJustInserted) {
                 QQmlError err;
-                auto memberName = propertyName->toString(m_modelCache->engine())->toQString();
+                auto memberName = propertyName->toString(v4)->toQString();
                 err.setDescription(QString::fromLatin1("%1 is %2. Adding an object with a %2 member does not create a role for it.").arg(memberName, propertyValue->isNull() ? QLatin1String("null") : QLatin1String("undefined")));
                 qmlWarning(nullptr, err);
             } else {
diff --git a/src/qmlmodels/qtqmlmodelsglobal_p.h b/src/qmlmodels/qtqmlmodelsglobal_p.h
index 1a1157138d..24df6ef7b3 100644
--- a/src/qmlmodels/qtqmlmodelsglobal_p.h
+++ b/src/qmlmodels/qtqmlmodelsglobal_p.h
@@ -59,5 +59,6 @@
 #define Q_QMLMODELS_AUTOTEST_EXPORT Q_AUTOTEST_EXPORT
 
 void Q_QMLMODELS_PRIVATE_EXPORT qml_register_types_QtQml_Models();
+GHS_KEEP_REFERENCE(qml_register_types_QtQml_Models);
 
 #endif // QTQMLMODELSGLOBAL_P_H
diff --git a/src/qmltest/quicktest.cpp b/src/qmltest/quicktest.cpp
index 312769b8d3..150db84533 100644
--- a/src/qmltest/quicktest.cpp
+++ b/src/qmltest/quicktest.cpp
@@ -309,14 +309,17 @@ private:
 
         if (!object) // Start at root of compilation unit if not enumerating a specific child
             object = compilationUnit->objectAt(0);
+        if (object->flags & Object::IsInlineComponentRoot)
+            return result;
 
         if (const auto superTypeUnit = compilationUnit->resolvedTypes.value(
                     object->inheritedTypeNameIndex)->compilationUnit()) {
             // We have a non-C++ super type, which could indicate we're a subtype of a TestCase
             if (testCaseType.isValid() && superTypeUnit->url() == testCaseType.sourceUrl())
                 result.isTestCase = true;
-            else
+            else if (superTypeUnit->url() != compilationUnit->url()) { // urls are the same for inline component, avoid infinite recursion
                 result = enumerateTestCases(superTypeUnit);
+            }
 
             if (result.isTestCase) {
                 // Look for override of name in this type
diff --git a/src/qmltyperegistrar/qmltypes.prf b/src/qmltyperegistrar/qmltypes.prf
index 354fa1736f..2cc0027b7e 100644
--- a/src/qmltyperegistrar/qmltypes.prf
+++ b/src/qmltyperegistrar/qmltypes.prf
@@ -44,7 +44,8 @@ qt_module_deps = $$replace(qt_module_deps, _private$, '')
 qt_module_deps = $$unique(qt_module_deps)
 
 for(dep, qt_module_deps) {
-    METATYPES_FILENAME = $$lower($$eval(QT.$${dep}.module))_metatypes.json
+    android:ABI = _$${ANDROID_TARGET_ARCH}
+    METATYPES_FILENAME = $$lower($$eval(QT.$${dep}.module))$${ABI}_metatypes.json
     INSTALLED_METATYPES = $$[QT_INSTALL_LIBS]/metatypes/$$METATYPES_FILENAME
     isEmpty(MODULE_BASE_OUTDIR) {
         QML_FOREIGN_METATYPES += $$INSTALLED_METATYPES
diff --git a/src/qmlworkerscript/qtqmlworkerscriptglobal_p.h b/src/qmlworkerscript/qtqmlworkerscriptglobal_p.h
index c75d5f3129..6452567f6b 100644
--- a/src/qmlworkerscript/qtqmlworkerscriptglobal_p.h
+++ b/src/qmlworkerscript/qtqmlworkerscriptglobal_p.h
@@ -58,5 +58,6 @@
 #define Q_QMLWORKERSCRIPT_AUTOTEST_EXPORT Q_AUTOTEST_EXPORT
 
 void Q_QMLWORKERSCRIPT_PRIVATE_EXPORT qml_register_types_QtQml_WorkerScript();
+GHS_KEEP_REFERENCE(qml_register_types_QtQml_WorkerScript);
 
 #endif // QTQMLWORKERSCRIPTGLOBAL_P_H
diff --git a/src/quick/accessible/qaccessiblequickitem_p.h b/src/quick/accessible/qaccessiblequickitem_p.h
index 931e995f0f..ccc9280ba0 100644
--- a/src/quick/accessible/qaccessiblequickitem_p.h
+++ b/src/quick/accessible/qaccessiblequickitem_p.h
@@ -54,6 +54,7 @@
 #include <QtQuick/QQuickItem>
 #include <QtQuick/QQuickView>
 #include <QtGui/qaccessibleobject.h>
+#include <QtQuick/private/qtquickglobal_p.h>
 
 QT_BEGIN_NAMESPACE
 
@@ -61,7 +62,7 @@ QT_BEGIN_NAMESPACE
 
 class QTextDocument;
 
-class QAccessibleQuickItem : public QAccessibleObject, public QAccessibleActionInterface, public QAccessibleValueInterface, public QAccessibleTextInterface
+class Q_QUICK_PRIVATE_EXPORT QAccessibleQuickItem : public QAccessibleObject, public QAccessibleActionInterface, public QAccessibleValueInterface, public QAccessibleTextInterface
 {
 public:
     QAccessibleQuickItem(QQuickItem *item);
diff --git a/src/quick/designer/qquickdesignersupportproperties.cpp b/src/quick/designer/qquickdesignersupportproperties.cpp
index 335795acf1..fb6a5fb324 100644
--- a/src/quick/designer/qquickdesignersupportproperties.cpp
+++ b/src/quick/designer/qquickdesignersupportproperties.cpp
@@ -137,11 +137,8 @@ QQuickDesignerSupport::PropertyNameList QQuickDesignerSupportProperties::propert
     if (inspectedObjects == nullptr)
         inspectedObjects = &localObjectList;
 
-
-    if (inspectedObjects->contains(object))
-        return propertyNameList;
-
-    inspectedObjects->append(object);
+    if (!inspectedObjects->contains(object))
+        inspectedObjects->append(object);
 
     const QMetaObject *metaObject = object->metaObject();
     for (int index = 0; index < metaObject->propertyCount(); ++index) {
@@ -194,12 +191,8 @@ QQuickDesignerSupport::PropertyNameList QQuickDesignerSupportProperties::allProp
     if (inspectedObjects == nullptr)
         inspectedObjects = &localObjectList;
 
-
-    if (inspectedObjects->contains(object))
-        return propertyNameList;
-
-    inspectedObjects->append(object);
-
+    if (!inspectedObjects->contains(object))
+        inspectedObjects->append(object);
 
     const QMetaObject *metaObject = object->metaObject();
 
diff --git a/src/quick/doc/snippets/qml/item/childrenRect.qml b/src/quick/doc/snippets/qml/item/childrenRect.qml
new file mode 100644
index 0000000000..769633dc2a
--- /dev/null
+++ b/src/quick/doc/snippets/qml/item/childrenRect.qml
@@ -0,0 +1,68 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the documentation of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:BSD$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** BSD License Usage
+** Alternatively, you may use this file under the terms of the BSD license
+** as follows:
+**
+** "Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions are
+** met:
+**   * Redistributions of source code must retain the above copyright
+**     notice, this list of conditions and the following disclaimer.
+**   * Redistributions in binary form must reproduce the above copyright
+**     notice, this list of conditions and the following disclaimer in
+**     the documentation and/or other materials provided with the
+**     distribution.
+**   * Neither the name of The Qt Company Ltd nor the names of its
+**     contributors may be used to endorse or promote products derived
+**     from this software without specific prior written permission.
+**
+**
+** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+import QtQuick 2.0
+
+//! [local]
+Item {
+    x: 50
+    y: 100
+
+    // prints: QRectF(-10, -20, 30, 40)
+    Component.onCompleted: print(childrenRect)
+
+    Item {
+        x: -10
+        y: -20
+        width: 30
+        height: 40
+    }
+}
+//! [local]
diff --git a/src/quick/doc/snippets/qquickview-ex.cpp b/src/quick/doc/snippets/qquickview-ex.cpp
index 32406f8f2f..5f93dfdbe8 100644
--- a/src/quick/doc/snippets/qquickview-ex.cpp
+++ b/src/quick/doc/snippets/qquickview-ex.cpp
@@ -59,3 +59,12 @@ int main(int argc, char *argv[])
     return app.exec();
 }
 //![0]
+
+void makeDocTeamHappyByKeepingExampleCompilable() {
+//![1]
+    QScopedPointer<QQuickView> view { new QQuickView };
+    view->setInitialProperties({"x, 100"}, {"width", 50});
+    view->setSource(QUrl::fromLocalFile("myqmlfile.qml"));
+    view->show();
+//![1]
+}
diff --git a/src/quick/items/qquickitem.cpp b/src/quick/items/qquickitem.cpp
index 67c4611d9e..81b0db0b69 100644
--- a/src/quick/items/qquickitem.cpp
+++ b/src/quick/items/qquickitem.cpp
@@ -1,9 +1,9 @@
 /****************************************************************************
 **
-** Copyright (C) 2016 The Qt Company Ltd.
+** Copyright (C) 2021 The Qt Company Ltd.
 ** Contact: https://www.qt.io/licensing/
 **
-** This file is part of the QtQuick module of the Qt Toolkit.
+** This file is part of the QtQuick module of the Qt Toolkit.fset
 **
 ** $QT_BEGIN_LICENSE:LGPL$
 ** Commercial License Usage
@@ -59,6 +59,7 @@
 #include <QtCore/private/qnumeric_p.h>
 #include <QtGui/qpa/qplatformtheme.h>
 #include <QtCore/qloggingcategory.h>
+#include <QtCore/private/qduplicatetracker_p.h>
 
 #include <private/qqmlglobal_p.h>
 #include <private/qqmlengine_p.h>
@@ -1883,7 +1884,23 @@ void QQuickItemPrivate::updateSubFocusItem(QQuickItem *scope, bool focus)
     \endqml
 
 
-    \section2 Key Handling
+    \section2 Event Handling
+
+    All Item-based visual types can use \l {Qt Quick Input Handlers}{Input Handlers}
+    to handle incoming input events (subclasses of QInputEvent), such as mouse,
+    touch and key events. This is the preferred declarative way to handle events.
+
+    An alternative way to handle touch events is to subclass QQuickItem, call
+    setAcceptTouchEvents() in the constructor, and override touchEvent().
+    \l {QEvent::setAccepted()}{Accept} the entire event to stop delivery to
+    items underneath, and to exclusively grab all the event's touch points.
+
+    Likewise, a QQuickItem subclass can call setAcceptedMouseButtons()
+    to register to receive mouse button events, setAcceptHoverEvents()
+    to receive hover events (mouse movements while no button is pressed),
+    and override the virtual functions mousePressEvent(), mouseMoveEvent(), and
+    mouseReleaseEvent(). Those can also accept the event to prevent further
+    delivery and get an implicit grab at the same time.
 
     Key handling is available to all Item-based visual types via the \l Keys
     attached property.  The \e Keys attached property provides basic signals
@@ -2504,6 +2521,7 @@ QQuickItem* QQuickItemPrivate::nextPrevItemInTabFocusChain(QQuickItem *item, boo
     QQuickItem *current = item;
     qCDebug(DBG_FOCUS) << "QQuickItemPrivate::nextPrevItemInTabFocusChain: startItem:" << startItem;
     qCDebug(DBG_FOCUS) << "QQuickItemPrivate::nextPrevItemInTabFocusChain: firstFromItem:" << firstFromItem;
+    QDuplicateTracker<QQuickItem *> cycleDetector;
     do {
         qCDebug(DBG_FOCUS) << "QQuickItemPrivate::nextPrevItemInTabFocusChain: current:" << current;
         qCDebug(DBG_FOCUS) << "QQuickItemPrivate::nextPrevItemInTabFocusChain: from:" << from;
@@ -2570,7 +2588,10 @@ QQuickItem* QQuickItemPrivate::nextPrevItemInTabFocusChain(QQuickItem *item, boo
         // traversed all of the chain (by compare the [current] item with [startItem])
         // Since the [startItem] might be promoted to its parent if it is invisible,
         // we still have to check [current] item with original start item
-        if ((current == startItem || current == originalStartItem) && from == firstFromItem) {
+        // We might also run into a cycle before we reach firstFromItem again
+        // but note that we have to ignore current if we are meant to skip it
+        if (((current == startItem || current == originalStartItem) && from == firstFromItem) ||
+                (!skip && cycleDetector.hasSeen(current))) {
             // wrapped around, avoid endless loops
             if (item == contentItem) {
                 qCDebug(DBG_FOCUS) << "QQuickItemPrivate::nextPrevItemInTabFocusChain: looped, return contentItem";
@@ -3055,8 +3076,9 @@ Returns a transform that maps points from item space into window space.
 */
 QTransform QQuickItemPrivate::itemToWindowTransform() const
 {
-    // XXX todo
-    QTransform rv = parentItem?QQuickItemPrivate::get(parentItem)->itemToWindowTransform():QTransform();
+    // item's parent must not be itself, otherwise calling itemToWindowTransform() on it is infinite recursion
+    Q_ASSERT(!parentItem || QQuickItemPrivate::get(parentItem) != this);
+    QTransform rv = parentItem ? QQuickItemPrivate::get(parentItem)->itemToWindowTransform() : QTransform();
     itemToParentTransform(rv);
     return rv;
 }
@@ -3650,6 +3672,10 @@ QQmlListProperty<QObject> QQuickItemPrivate::data()
 
     This property is useful if you need to access the collective geometry
     of an item's children in order to correctly size the item.
+
+    The geometry that is returned is local to the item. For example:
+
+    \snippet qml/item/childrenRect.qml local
 */
 /*!
     \property QQuickItem::childrenRect
@@ -3659,6 +3685,10 @@ QQmlListProperty<QObject> QQuickItemPrivate::data()
 
     This property is useful if you need to access the collective geometry
     of an item's children in order to correctly size the item.
+
+    The geometry that is returned is local to the item. For example:
+
+    \snippet qml/item/childrenRect.qml local
 */
 QRectF QQuickItem::childrenRect()
 {
@@ -3753,6 +3783,14 @@ void QQuickItem::geometryChanged(const QRectF &newGeometry, const QRectF &oldGeo
         emit widthChanged();
     if (change.heightChange())
         emit heightChanged();
+#if QT_CONFIG(accessibility)
+    if (QAccessible::isActive()) {
+        if (QObject *acc = QQuickAccessibleAttached::findAccessible(this)) {
+            QAccessibleEvent ev(acc, QAccessible::LocationChanged);
+            QAccessible::updateAccessibility(&ev);
+        }
+    }
+#endif
 }
 
 /*!
@@ -7293,7 +7331,9 @@ bool QQuickItem::isAncestorOf(const QQuickItem *child) const
     If an item does not accept the mouse button for a particular mouse event,
     the mouse event will not be delivered to the item and will be delivered
     to the next item in the item hierarchy instead.
-  */
+
+    \sa acceptTouchEvents()
+*/
 Qt::MouseButtons QQuickItem::acceptedMouseButtons() const
 {
     Q_D(const QQuickItem);
@@ -7302,7 +7342,13 @@ Qt::MouseButtons QQuickItem::acceptedMouseButtons() const
 
 /*!
     Sets the mouse buttons accepted by this item to \a buttons.
-  */
+
+    \note In Qt 5, calling setAcceptedMouseButtons() implicitly caused
+    an item to receive touch events as well as mouse events; but it was
+    recommended to call setAcceptTouchEvents() to subscribe for them.
+    In Qt 6, it is necessary to call setAcceptTouchEvents() to continue
+    to receive them.
+*/
 void QQuickItem::setAcceptedMouseButtons(Qt::MouseButtons buttons)
 {
     Q_D(QQuickItem);
@@ -7352,6 +7398,12 @@ bool QQuickItem::isUnderMouse() const
     if (!d->window)
         return false;
 
+    // QQuickWindow handles QEvent::Leave to reset the lastMousePosition
+    // FIXME: Using QPointF() as the reset value means an item will not be
+    // under the mouse if the mouse is at 0,0 of the window.
+    if (QQuickWindowPrivate::get(d->window)->lastMousePosition == QPointF())
+        return false;
+
     QPointF cursorPos = QGuiApplicationPrivate::lastCursorPosition;
     return contains(mapFromScene(d->window->mapFromGlobal(cursorPos.toPoint())));
 }
@@ -7766,22 +7818,23 @@ void QQuickItem::setKeepTouchGrab(bool keep)
 }
 
 /*!
-  \qmlmethod bool QtQuick::Item::contains(point point)
+    \qmlmethod bool QtQuick::Item::contains(point point)
 
-  Returns true if this item contains \a point, which is in local coordinates;
-  returns false otherwise.
-  */
+    Returns \c true if this item contains \a point, which is in local coordinates;
+    returns \c false otherwise.  This is the same check that is used for
+    hit-testing a QEventPoint during event delivery, and is affected by
+    containmentMask() if it is set.
+*/
 /*!
-  Returns true if this item contains \a point, which is in local coordinates;
-  returns false otherwise.
+    Returns \c true if this item contains \a point, which is in local coordinates;
+    returns \c false otherwise.
 
-  This function can be overwritten in order to handle point collisions in items
-  with custom shapes. The default implementation checks if the point is inside
-  the item's bounding rect.
+    This function can be overridden in order to handle point collisions in items
+    with custom shapes. The default implementation checks whether the point is inside
+    containmentMask() if it is set, or inside the bounding box otherwise.
 
-  Note that this method is generally used to check whether the item is under the mouse cursor,
-  and for that reason, the implementation of this function should be as light-weight
-  as possible.
+    \note This method is used for hit-testing each QEventPoint during event
+    delivery, so the implementation should be kept as lightweight as possible.
 */
 bool QQuickItem::contains(const QPointF &point) const
 {
diff --git a/src/quick/items/qquickitemanimation.cpp b/src/quick/items/qquickitemanimation.cpp
index 23694e2de3..dfb56ccc00 100644
--- a/src/quick/items/qquickitemanimation.cpp
+++ b/src/quick/items/qquickitemanimation.cpp
@@ -230,8 +230,8 @@ QAbstractAnimationJob* QQuickParentAnimation::transition(QQuickStateActions &act
 {
     Q_D(QQuickParentAnimation);
 
-    QQuickParentAnimationData *data = new QQuickParentAnimationData;
-    QQuickParentAnimationData *viaData = new QQuickParentAnimationData;
+    std::unique_ptr<QQuickParentAnimationData> data(new QQuickParentAnimationData);
+    std::unique_ptr<QQuickParentAnimationData> viaData(new QQuickParentAnimationData);
 
     bool hasExplicit = false;
     if (d->target && d->newParent) {
@@ -377,8 +377,8 @@ QAbstractAnimationJob* QQuickParentAnimation::transition(QQuickStateActions &act
         QParallelAnimationGroupJob *ag = new QParallelAnimationGroupJob;
 
         if (d->via)
-            viaAction->setAnimAction(viaData);
-        targetAction->setAnimAction(data);
+            viaAction->setAnimAction(viaData.release());
+        targetAction->setAnimAction(data.release());
 
         //take care of any child animations
         bool valid = d->defaultProperty.isValid();
@@ -405,9 +405,6 @@ QAbstractAnimationJob* QQuickParentAnimation::transition(QQuickStateActions &act
             topLevelGroup->appendAnimation(d->via ? viaAction : targetAction);
         }
         return initInstance(topLevelGroup);
-    } else {
-        delete data;
-        delete viaData;
     }
     return nullptr;
 }
diff --git a/src/quick/items/qquicklistview.cpp b/src/quick/items/qquicklistview.cpp
index 0f9394f695..1001b34c3c 100644
--- a/src/quick/items/qquicklistview.cpp
+++ b/src/quick/items/qquicklistview.cpp
@@ -382,6 +382,83 @@ private:
     }
 };
 
+/*! \internal
+    \brief A helper class for iterating over a model that might change
+
+    When populating the ListView from a model under normal
+    circumstances, we would iterate over the range of model indices
+    correspondning to the visual range, and basically call
+    createItem(index++) in order to create each item.
+
+    This will also emit Component.onCompleted() for each item, which
+    might do some weird things...  For instance, it might remove itself
+    from the model, and this might change model count and the indices
+    of the other subsequent entries in the model.
+
+    This class takes such changes to the model into consideration while
+    iterating, and will adjust the iterator index and keep track of
+    whether the iterator has reached the end of the range.
+
+    It keeps track of changes to the model by connecting to
+    QQmlInstanceModel::modelUpdated() from its constructor.
+    When destroyed, it will automatically disconnect. You can
+    explicitly disconnect earlier by calling \fn disconnect().
+*/
+class MutableModelIterator {
+public:
+    MutableModelIterator(QQmlInstanceModel *model, int iBegin, int iEnd)
+        : removedAtIndex(false)
+        , backwards(iEnd < iBegin)
+    {
+        conn = QObject::connect(model, &QQmlInstanceModel::modelUpdated,
+                [&] (const QQmlChangeSet &changeSet, bool /*reset*/)
+        {
+            for (const QQmlChangeSet::Change &rem : changeSet.removes()) {
+                idxEnd -= rem.count;
+                if (rem.start() <= index) {
+                    index -= rem.count;
+                    if (index < rem.start() + rem.count)
+                        removedAtIndex = true; // model index was removed
+                }
+            }
+            for (const QQmlChangeSet::Change &ins : changeSet.inserts()) {
+                idxEnd += ins.count;
+                if (ins.start() <= index)
+                    index += ins.count;
+            }
+        }
+        );
+        index = iBegin;
+        idxEnd = iEnd;
+    }
+
+    bool hasNext() const {
+        return backwards ? index > idxEnd : index < idxEnd;
+    }
+
+    void next() { index += (backwards ? -1 : +1); }
+
+    ~MutableModelIterator()
+    {
+        disconnect();
+    }
+
+    void disconnect()
+    {
+        if (conn) {
+            QObject::disconnect(conn);
+            conn = QMetaObject::Connection();   // set to nullptr
+        }
+    }
+    int index = 0;
+    int idxEnd;
+    unsigned removedAtIndex : 1;
+    unsigned backwards : 1;
+private:
+    QMetaObject::Connection conn;
+};
+
+
 //----------------------------------------------------------------------------
 
 bool QQuickListViewPrivate::isContentFlowReversed() const
@@ -3570,7 +3647,6 @@ bool QQuickListViewPrivate::applyInsertionChange(const QQmlChangeSet::Change &ch
     if (insertResult->visiblePos.isValid() && pos < insertResult->visiblePos) {
         // Insert items before the visible item.
         int insertionIdx = index;
-        int i = 0;
         qreal from = tempPos - displayMarginBeginning - buffer;
 
         if (insertionIdx < visibleIndex) {
@@ -3579,15 +3655,18 @@ bool QQuickListViewPrivate::applyInsertionChange(const QQmlChangeSet::Change &ch
                 insertResult->sizeChangesBeforeVisiblePos += count * (averageSize + spacing);
             }
         } else {
-            for (i = count-1; i >= 0 && pos >= from; --i) {
+            MutableModelIterator it(model, modelIndex + count - 1, modelIndex -1);
+            for (; it.hasNext() && pos >= from; it.next()) {
                 // item is before first visible e.g. in cache buffer
                 FxViewItem *item = nullptr;
-                if (change.isMove() && (item = currentChanges.removedItems.take(change.moveKey(modelIndex + i))))
-                    item->index = modelIndex + i;
+                if (change.isMove() && (item = currentChanges.removedItems.take(change.moveKey(it.index))))
+                    item->index = it.index;
                 if (!item)
-                    item = createItem(modelIndex + i, QQmlIncubator::Synchronous);
+                    item = createItem(it.index, QQmlIncubator::Synchronous);
                 if (!item)
                     return false;
+                if (it.removedAtIndex)
+                    continue;
 
                 visibleAffected = true;
                 visibleItems.insert(insertionIdx, item);
@@ -3620,16 +3699,20 @@ bool QQuickListViewPrivate::applyInsertionChange(const QQmlChangeSet::Change &ch
         }
 
     } else {
-        for (int i = 0; i < count && pos <= lastVisiblePos; ++i) {
+        MutableModelIterator it(model, modelIndex, modelIndex + count);
+        for (; it.hasNext() && pos <= lastVisiblePos; it.next()) {
             visibleAffected = true;
             FxViewItem *item = nullptr;
-            if (change.isMove() && (item = currentChanges.removedItems.take(change.moveKey(modelIndex + i))))
-                item->index = modelIndex + i;
+            if (change.isMove() && (item = currentChanges.removedItems.take(change.moveKey(it.index))))
+                item->index = it.index;
             bool newItem = !item;
+            it.removedAtIndex = false;
             if (!item)
-                item = createItem(modelIndex + i, QQmlIncubator::Synchronous);
+                item = createItem(it.index, QQmlIncubator::Synchronous);
             if (!item)
                 return false;
+            if (it.removedAtIndex)
+                continue;
 
             visibleItems.insert(index, item);
             if (index == 0)
@@ -3650,6 +3733,7 @@ bool QQuickListViewPrivate::applyInsertionChange(const QQmlChangeSet::Change &ch
             pos += item->size() + spacing;
             ++index;
         }
+        it.disconnect();
 
         if (0 < index && index < visibleItems.count()) {
             FxViewItem *prevItem = visibleItems.at(index - 1);
diff --git a/src/quick/items/qquickloader.cpp b/src/quick/items/qquickloader.cpp
index 8cd63a4236..7fbe66fdda 100644
--- a/src/quick/items/qquickloader.cpp
+++ b/src/quick/items/qquickloader.cpp
@@ -718,7 +718,6 @@ void QQuickLoaderPrivate::incubatorStateChanged(QQmlIncubator::Status status)
     emit q->progressChanged();
     if (status == QQmlIncubator::Ready)
         emit q->loaded();
-    disposeInitialPropertyValues(); // cleanup
 }
 
 void QQuickLoaderPrivate::_q_sourceLoaded()
@@ -738,6 +737,9 @@ void QQuickLoaderPrivate::_q_sourceLoaded()
         return;
     }
 
+    if (!active)
+        return;
+
     QQmlContext *creationContext = component->creationContext();
     if (!creationContext) creationContext = qmlContext(q);
     itemContext = new QQmlContext(creationContext);
diff --git a/src/quick/items/qquickmousearea_p_p.h b/src/quick/items/qquickmousearea_p_p.h
index fba383e268..0d63618622 100644
--- a/src/quick/items/qquickmousearea_p_p.h
+++ b/src/quick/items/qquickmousearea_p_p.h
@@ -61,7 +61,6 @@ QT_BEGIN_NAMESPACE
 
 class QQuickMouseEvent;
 class QQuickMouseArea;
-class QQuickPointerMask;
 class QQuickMouseAreaPrivate : public QQuickItemPrivate
 {
     Q_DECLARE_PUBLIC(QQuickMouseArea)
@@ -100,7 +99,6 @@ public:
 #if QT_CONFIG(quick_draganddrop)
     QQuickDrag *drag;
 #endif
-    QPointer<QQuickPointerMask> mask;
     QPointF startScene;
     QPointF targetStartPos;
     QPointF lastPos;
diff --git a/src/quick/items/qquickshadereffectsource.cpp b/src/quick/items/qquickshadereffectsource.cpp
index 4f61d61309..b298ed74da 100644
--- a/src/quick/items/qquickshadereffectsource.cpp
+++ b/src/quick/items/qquickshadereffectsource.cpp
@@ -344,7 +344,6 @@ void QQuickShaderEffectSource::setSourceItem(QQuickItem *item)
             d->refFromEffectItem(m_hideSource);
             d->addItemChangeListener(this, QQuickItemPrivate::Geometry);
             connect(m_sourceItem, SIGNAL(destroyed(QObject*)), this, SLOT(sourceItemDestroyed(QObject*)));
-            connect(m_sourceItem, SIGNAL(parentChanged(QQuickItem*)), this, SLOT(sourceItemParentChanged(QQuickItem*)));
         } else {
             qWarning("ShaderEffectSource: sourceItem and ShaderEffectSource must both be children of the same window.");
             m_sourceItem = nullptr;
@@ -364,13 +363,6 @@ void QQuickShaderEffectSource::sourceItemDestroyed(QObject *item)
 }
 
 
-void QQuickShaderEffectSource::sourceItemParentChanged(QQuickItem *parent)
-{
-    if (!parent && m_texture)
-        m_texture->setItem(0);
-}
-
-
 /*!
     \qmlproperty rect QtQuick::ShaderEffectSource::sourceRect
 
diff --git a/src/quick/items/qquickshadereffectsource_p.h b/src/quick/items/qquickshadereffectsource_p.h
index 4deb6c70a3..c0a1ccab78 100644
--- a/src/quick/items/qquickshadereffectsource_p.h
+++ b/src/quick/items/qquickshadereffectsource_p.h
@@ -173,7 +173,6 @@ Q_SIGNALS:
 private Q_SLOTS:
     void sourceItemDestroyed(QObject *item);
     void invalidateSceneGraph();
-    void sourceItemParentChanged(QQuickItem *parent);
 
 protected:
     void releaseResources() override;
diff --git a/src/quick/items/qquicktableview.cpp b/src/quick/items/qquicktableview.cpp
index 7b73fcb393..f9454fc5cb 100644
--- a/src/quick/items/qquicktableview.cpp
+++ b/src/quick/items/qquicktableview.cpp
@@ -642,6 +642,28 @@ int QQuickTableViewPrivate::nextVisibleEdgeIndex(Qt::Edge edge, int startIndex)
     return foundIndex;
 }
 
+bool QQuickTableViewPrivate::allColumnsLoaded()
+{
+    // Returns true if all the columns in the model (that are not
+    // hidden by the columnWidthProvider) are currently loaded and visible.
+    const bool firstColumnLoaded = nextVisibleEdgeIndexAroundLoadedTable(Qt::LeftEdge) == kEdgeIndexAtEnd;
+    if (!firstColumnLoaded)
+        return false;
+    bool lastColumnLoaded = nextVisibleEdgeIndexAroundLoadedTable(Qt::RightEdge) == kEdgeIndexAtEnd;
+    return lastColumnLoaded;
+}
+
+bool QQuickTableViewPrivate::allRowsLoaded()
+{
+    // Returns true if all the rows in the model (that are not hidden
+    // by the columnWidthProvider) are currently loaded and visible.
+    const bool firstColumnLoaded = nextVisibleEdgeIndexAroundLoadedTable(Qt::TopEdge) == kEdgeIndexAtEnd;
+    if (!firstColumnLoaded)
+        return false;
+    bool lastColumnLoaded = nextVisibleEdgeIndexAroundLoadedTable(Qt::BottomEdge) == kEdgeIndexAtEnd;
+    return lastColumnLoaded;
+}
+
 void QQuickTableViewPrivate::updateContentWidth()
 {
     // Note that we actually never really know what the content size / size of the full table will
@@ -927,6 +949,15 @@ void QQuickTableViewPrivate::syncLoadedTableRectFromLoadedTable()
 
 QQuickTableViewPrivate::RebuildOptions QQuickTableViewPrivate::checkForVisibilityChanges()
 {
+    // This function will check if there are any visibility changes among
+    // the _already loaded_ rows and columns. Note that there can be rows
+    // and columns to the bottom or right that was not loaded, but should
+    // now become visible (in case there is free space around the table).
+    if (loadedItems.isEmpty()) {
+        // Report no changes
+        return RebuildOption::None;
+    }
+
     // Go through all columns from first to last, find the columns that used
     // to be hidden and not loaded, and check if they should become visible
     // (and vice versa). If there is a change, we need to rebuild.
@@ -971,9 +1002,6 @@ QQuickTableViewPrivate::RebuildOptions QQuickTableViewPrivate::checkForVisibilit
 
 void QQuickTableViewPrivate::forceLayout()
 {
-    if (loadedItems.isEmpty())
-        return;
-
     clearEdgeSizeCache();
     RebuildOptions rebuildOptions = RebuildOption::None;
 
@@ -1760,11 +1788,8 @@ void QQuickTableViewPrivate::calculateTopLeft(QPoint &topLeftCell, QPointF &topL
         const auto syncView_d = syncView->d_func();
 
         if (syncView_d->loadedItems.isEmpty()) {
-            // The sync view contains no loaded items. This probably means
-            // that it has not been rebuilt yet. Which also means that
-            // we cannot rebuild anything before this happens.
-            topLeftCell.rx() = kEdgeIndexNotSet;
-            topLeftCell.ry() = kEdgeIndexNotSet;
+            topLeftCell.rx() = 0;
+            topLeftCell.ry() = 0;
             return;
         }
 
@@ -1926,12 +1951,12 @@ void QQuickTableViewPrivate::layoutAfterLoadingInitialTable()
     relayoutTableItems();
     syncLoadedTableRectFromLoadedTable();
 
-    if (rebuildOptions.testFlag(RebuildOption::CalculateNewContentWidth)) {
+    if (rebuildOptions.testFlag(RebuildOption::CalculateNewContentWidth) || allColumnsLoaded()) {
         updateAverageColumnWidth();
         updateContentWidth();
     }
 
-    if (rebuildOptions.testFlag(RebuildOption::CalculateNewContentHeight)) {
+    if (rebuildOptions.testFlag(RebuildOption::CalculateNewContentHeight) || allRowsLoaded()) {
         updateAverageRowHeight();
         updateContentHeight();
     }
diff --git a/src/quick/items/qquicktableview_p_p.h b/src/quick/items/qquicktableview_p_p.h
index 403a77c3ea..df52672424 100644
--- a/src/quick/items/qquicktableview_p_p.h
+++ b/src/quick/items/qquicktableview_p_p.h
@@ -368,6 +368,8 @@ public:
 
     int nextVisibleEdgeIndex(Qt::Edge edge, int startIndex);
     int nextVisibleEdgeIndexAroundLoadedTable(Qt::Edge edge);
+    bool allColumnsLoaded();
+    bool allRowsLoaded();
     inline int edgeToArrayIndex(Qt::Edge edge);
     void clearEdgeSizeCache();
 
diff --git a/src/quick/items/qquicktext.cpp b/src/quick/items/qquicktext.cpp
index 90469ee82b..e823ca1095 100644
--- a/src/quick/items/qquicktext.cpp
+++ b/src/quick/items/qquicktext.cpp
@@ -398,6 +398,8 @@ void QQuickTextPrivate::updateSize()
         layedOutTextRect = QRectF(0, 0, 0, fontHeight);
         advance = QSizeF();
         signalSizeChange(previousSize);
+        lineCount = 1;
+        emit q->lineCountChanged();
         updateType = UpdatePaintNode;
         q->update();
         return;
@@ -1177,8 +1179,8 @@ QRectF QQuickTextPrivate::setupTextLayout(qreal *const baseline)
     QTextLine firstLine = visibleCount == 1 && elideLayout
             ? elideLayout->lineAt(0)
             : layout.lineAt(0);
-    Q_ASSERT(firstLine.isValid());
-    *baseline = firstLine.y() + firstLine.ascent();
+    if (firstLine.isValid())
+        *baseline = firstLine.y() + firstLine.ascent();
 
     if (!customLayout)
         br.setHeight(height);
@@ -2166,7 +2168,7 @@ void QQuickText::resetMaximumLineCount()
     <img src="" align="top,middle,bottom" width="" height=""> - inline images
     <ol type="">, <ul type=""> and <li> - ordered and unordered lists
     <pre></pre> - preformatted
-    &gt; &lt; &amp;
+    &gt; &lt; &amp; &quot; &nbsp; &apos;
     \endcode
 
     \c Text.StyledText parser is strict, requiring tags to be correctly nested.
@@ -2425,7 +2427,10 @@ void QQuickText::geometryChanged(const QRectF &newGeometry, const QRectF &oldGeo
             }
         }
     } else if (!heightChanged && widthMaximum) {
-        goto geomChangeDone;
+        if (!qFuzzyIsNull(oldGeometry.width())) {
+            // no change to height, width is adequate and wasn't 0 before
+            goto geomChangeDone;
+        }
     }
 
     if (d->updateOnComponentComplete || d->textHasChanged) {
diff --git a/src/quick/items/qquicktextcontrol.cpp b/src/quick/items/qquicktextcontrol.cpp
index 8db2a38b11..742d36a789 100644
--- a/src/quick/items/qquicktextcontrol.cpp
+++ b/src/quick/items/qquicktextcontrol.cpp
@@ -949,6 +949,12 @@ void QQuickTextControlPrivate::keyPressEvent(QKeyEvent *e)
 process:
     {
         if (q->isAcceptableInput(e)) {
+#if QT_CONFIG(im)
+            // QTBUG-90362
+            // Before key press event will be handled, pre-editing part should be finished
+            if (isPreediting())
+                commitPreedit();
+#endif
             if (overwriteMode
                 // no need to call deleteChar() if we have a selection, insertText
                 // does it already
diff --git a/src/quick/items/qquicktextedit.cpp b/src/quick/items/qquicktextedit.cpp
index 068571f15e..5df5e5adcf 100644
--- a/src/quick/items/qquicktextedit.cpp
+++ b/src/quick/items/qquicktextedit.cpp
@@ -822,6 +822,7 @@ void QQuickTextEditPrivate::setTopPadding(qreal value, bool reset)
     }
     if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
         q->updateSize();
+        q->updateWholeDocument();
         emit q->topPaddingChanged();
     }
 }
@@ -836,6 +837,7 @@ void QQuickTextEditPrivate::setLeftPadding(qreal value, bool reset)
     }
     if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
         q->updateSize();
+        q->updateWholeDocument();
         emit q->leftPaddingChanged();
     }
 }
@@ -850,6 +852,7 @@ void QQuickTextEditPrivate::setRightPadding(qreal value, bool reset)
     }
     if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
         q->updateSize();
+        q->updateWholeDocument();
         emit q->rightPaddingChanged();
     }
 }
@@ -864,6 +867,7 @@ void QQuickTextEditPrivate::setBottomPadding(qreal value, bool reset)
     }
     if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
         q->updateSize();
+        q->updateWholeDocument();
         emit q->bottomPaddingChanged();
     }
 }
diff --git a/src/quick/items/qquicktextinput.cpp b/src/quick/items/qquicktextinput.cpp
index 6275b298ed..0e7f52e816 100644
--- a/src/quick/items/qquicktextinput.cpp
+++ b/src/quick/items/qquicktextinput.cpp
@@ -2952,6 +2952,7 @@ void QQuickTextInputPrivate::setTopPadding(qreal value, bool reset)
     }
     if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
         updateLayout();
+        q->updateCursorRectangle();
         emit q->topPaddingChanged();
     }
 }
@@ -2966,6 +2967,7 @@ void QQuickTextInputPrivate::setLeftPadding(qreal value, bool reset)
     }
     if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
         updateLayout();
+        q->updateCursorRectangle();
         emit q->leftPaddingChanged();
     }
 }
@@ -2980,6 +2982,7 @@ void QQuickTextInputPrivate::setRightPadding(qreal value, bool reset)
     }
     if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
         updateLayout();
+        q->updateCursorRectangle();
         emit q->rightPaddingChanged();
     }
 }
@@ -2994,6 +2997,7 @@ void QQuickTextInputPrivate::setBottomPadding(qreal value, bool reset)
     }
     if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
         updateLayout();
+        q->updateCursorRectangle();
         emit q->bottomPaddingChanged();
     }
 }
@@ -3429,17 +3433,19 @@ void QQuickTextInputPrivate::processInputMethodEvent(QInputMethodEvent *event)
     if (event->replacementStart() <= 0)
         c += event->commitString().length() - qMin(-event->replacementStart(), event->replacementLength());
 
-    m_cursor += event->replacementStart();
-    if (m_cursor < 0)
-        m_cursor = 0;
+    int cursorInsertPos = m_cursor + event->replacementStart();
+    if (cursorInsertPos < 0)
+        cursorInsertPos = 0;
 
     // insert commit string
     if (event->replacementLength()) {
-        m_selstart = m_cursor;
+        m_selstart = cursorInsertPos;
         m_selend = m_selstart + event->replacementLength();
         m_selend = qMin(m_selend, m_text.length());
         removeSelectedText();
     }
+    m_cursor = cursorInsertPos;
+
     if (!event->commitString().isEmpty()) {
         internalInsert(event->commitString());
         cursorPositionChanged = true;
@@ -3466,8 +3472,12 @@ void QQuickTextInputPrivate::processInputMethodEvent(QInputMethodEvent *event)
     }
     QString oldPreeditString = m_textLayout.preeditAreaText();
     m_textLayout.setPreeditArea(m_cursor, event->preeditString());
-    if (oldPreeditString != m_textLayout.preeditAreaText())
+    if (oldPreeditString != m_textLayout.preeditAreaText()) {
         emit q->preeditTextChanged();
+        if (!event->preeditString().isEmpty() && m_undoPreeditState == -1)
+            // Pre-edit text started. Remember state for undo purpose.
+            m_undoPreeditState = priorState;
+    }
     const int oldPreeditCursor = m_preeditCursor;
     m_preeditCursor = event->preeditString().length();
     hasImState = !event->preeditString().isEmpty();
@@ -3494,11 +3504,10 @@ void QQuickTextInputPrivate::processInputMethodEvent(QInputMethodEvent *event)
     m_textLayout.setFormats(formats);
 
     updateDisplayText(/*force*/ true);
-    if ((cursorPositionChanged && !emitCursorPositionChanged())
-            || m_preeditCursor != oldPreeditCursor
-            || isGettingInput) {
+    if (cursorPositionChanged && emitCursorPositionChanged())
+        q->updateInputMethod(Qt::ImCursorPosition | Qt::ImAnchorPosition);
+    else if (m_preeditCursor != oldPreeditCursor || isGettingInput)
         q->updateCursorRectangle();
-    }
 
     if (isGettingInput)
         finishChange(priorState);
@@ -3510,6 +3519,11 @@ void QQuickTextInputPrivate::processInputMethodEvent(QInputMethodEvent *event)
         q->updateInputMethod(Qt::ImCursorRectangle | Qt::ImAnchorRectangle
                             | Qt::ImCurrentSelection);
     }
+
+    // Empty pre-edit text handled. Clean m_undoPreeditState
+    if (event->preeditString().isEmpty())
+        m_undoPreeditState = -1;
+
 }
 #endif // im
 
@@ -3586,6 +3600,12 @@ bool QQuickTextInputPrivate::finishChange(int validateFromState, bool update, bo
         if (m_maskData)
             checkIsValid();
 
+#if QT_CONFIG(im)
+        // If we were during pre-edit, validateFromState should point to the state before pre-edit
+        // has been started. Choose the correct oldest remembered state
+        if (m_undoPreeditState >= 0 && (m_undoPreeditState < validateFromState || validateFromState < 0))
+                validateFromState = m_undoPreeditState;
+#endif
         if (validateFromState >= 0 && wasValidInput && !m_validInput) {
             if (m_transactions.count())
                 return false;
@@ -3658,6 +3678,9 @@ void QQuickTextInputPrivate::internalSetText(const QString &txt, int pos, bool e
     }
     m_history.clear();
     m_undoState = 0;
+#if QT_CONFIG(im)
+    m_undoPreeditState = -1;
+#endif
     m_cursor = (pos < 0 || pos > m_text.length()) ? m_text.length() : pos;
     m_textDirty = (oldText != m_text);
 
@@ -3831,8 +3854,7 @@ void QQuickTextInputPrivate::parseInputMask(const QString &maskFields)
     int delimiter = maskFields.indexOf(QLatin1Char(';'));
     if (maskFields.isEmpty() || delimiter == 0) {
         if (m_maskData) {
-            delete [] m_maskData;
-            m_maskData = nullptr;
+            m_maskData.reset(nullptr);
             m_maxLength = 32767;
             internalSetText(QString());
         }
@@ -3863,8 +3885,7 @@ void QQuickTextInputPrivate::parseInputMask(const QString &maskFields)
             m_maxLength++;
     }
 
-    delete [] m_maskData;
-    m_maskData = new MaskInputData[m_maxLength];
+    m_maskData.reset(new MaskInputData[m_maxLength]);
 
     MaskInputData::Casemode m = MaskInputData::NoCaseMode;
     c = 0;
@@ -4715,6 +4736,7 @@ void QQuickTextInput::setPadding(qreal padding)
 
     d->extra.value().padding = padding;
     d->updateLayout();
+    updateCursorRectangle();
     emit paddingChanged();
     if (!d->extra.isAllocated() || !d->extra->explicitTopPadding)
         emit topPaddingChanged();
diff --git a/src/quick/items/qquicktextinput_p_p.h b/src/quick/items/qquicktextinput_p_p.h
index 7965f3d3f4..fa92e608b7 100644
--- a/src/quick/items/qquicktextinput_p_p.h
+++ b/src/quick/items/qquicktextinput_p_p.h
@@ -58,6 +58,8 @@
 
 #include "qplatformdefs.h"
 
+#include <memory>
+
 //
 //  W A R N I N G
 //  -------------
@@ -108,6 +110,7 @@ public:
         , m_cursor(0)
 #if QT_CONFIG(im)
         , m_preeditCursor(0)
+        , m_undoPreeditState(-1)
 #endif
         , m_blinkEnabled(false)
         , m_blinkTimer(0)
@@ -230,7 +233,7 @@ public:
 
     QQuickItem *cursorItem;
     QQuickTextNode *textNode;
-    MaskInputData *m_maskData;
+    std::unique_ptr<MaskInputData[]> m_maskData;
     QInputControl *m_inputControl;
 
     QList<int> m_transactions;
@@ -246,6 +249,7 @@ public:
     int m_cursor;
 #if QT_CONFIG(im)
     int m_preeditCursor;
+    int m_undoPreeditState;
 #endif
     bool m_blinkEnabled;
     int m_blinkTimer;
@@ -333,7 +337,13 @@ public:
 
     bool isUndoAvailable() const { return !m_readOnly && m_undoState; }
     bool isRedoAvailable() const { return !m_readOnly && m_undoState < (int)m_history.size(); }
-    void clearUndo() { m_history.clear(); m_undoState = 0; }
+    void clearUndo() {
+            m_history.clear();
+            m_undoState = 0;
+#if QT_CONFIG(im)
+            m_undoPreeditState = -1;
+#endif
+    }
 
     bool allSelected() const { return !m_text.isEmpty() && m_selstart == 0 && m_selend == (int)m_text.length(); }
     bool hasSelectedText() const { return !m_text.isEmpty() && m_selend > m_selstart; }
diff --git a/src/quick/items/qquickview.cpp b/src/quick/items/qquickview.cpp
index 97f6689d8a..b3a5270e9b 100644
--- a/src/quick/items/qquickview.cpp
+++ b/src/quick/items/qquickview.cpp
@@ -240,7 +240,11 @@ void QQuickView::setSource(const QUrl& url)
    Sets the initial properties \a initialProperties with which the QML
    component gets initialized after calling \l QQuickView::setSource().
 
+   \snippet qquickview-ex.cpp 1
+
    \note You can only use this function to initialize top-level properties.
+   \note This function should always be called before setSource, as it has
+   no effect once the component has become \c Ready.
 
    \sa QQmlComponent::createWithInitialProperties()
    \since 5.14
diff --git a/src/quick/items/qquickwindow.cpp b/src/quick/items/qquickwindow.cpp
index d0c9ad5454..c956c85091 100644
--- a/src/quick/items/qquickwindow.cpp
+++ b/src/quick/items/qquickwindow.cpp
@@ -164,7 +164,7 @@ protected:
 
 public slots:
     void incubate() {
-        if (incubatingObjectCount()) {
+        if (m_renderLoop && incubatingObjectCount()) {
             if (m_renderLoop->interleaveIncubation()) {
                 incubateFor(m_incubation_time);
             } else {
@@ -180,12 +180,12 @@ public slots:
 protected:
     void incubatingObjectCountChanged(int count) override
     {
-        if (count && !m_renderLoop->interleaveIncubation())
+        if (count && m_renderLoop && !m_renderLoop->interleaveIncubation())
             incubateAgain();
     }
 
 private:
-    QSGRenderLoop *m_renderLoop;
+    QPointer<QSGRenderLoop> m_renderLoop;
     int m_incubation_time;
     int m_timer;
 };
@@ -450,15 +450,14 @@ void QQuickWindow::physicalDpiChanged()
 void QQuickWindow::handleScreenChanged(QScreen *screen)
 {
     Q_D(QQuickWindow);
+    disconnect(d->physicalDpiChangedConnection);
     if (screen) {
         physicalDpiChanged();
         // When physical DPI changes on the same screen, either the resolution or the device pixel
         // ratio changed. We must check what it is. Device pixel ratio does not have its own
         // ...Changed() signal.
-        d->physicalDpiChangedConnection = connect(screen, SIGNAL(physicalDotsPerInchChanged(qreal)),
-                                                  this, SLOT(physicalDpiChanged()));
-    } else {
-        disconnect(d->physicalDpiChangedConnection);
+        d->physicalDpiChangedConnection = connect(screen, &QScreen::physicalDotsPerInchChanged,
+                                                  this, &QQuickWindow::physicalDpiChanged);
     }
 
     d->forcePolish();
@@ -2864,6 +2863,14 @@ void QQuickWindowPrivate::deliverMatchingPointsToItem(QQuickItem *item, QQuickPo
 {
     Q_Q(QQuickWindow);
     QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+#if defined(Q_OS_ANDROID) && QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+    // QTBUG-85379
+    // In QT_VERSION below 6.0.0 touchEnabled for QtQuickItems is set by default to true
+    // It causes delivering touch events to Items which are not interested
+    // In some cases (like using Material Style in Android) it may cause a crash
+    if (itemPrivate->wasDeleted)
+        return;
+#endif
     pointerEvent->localize(item);
 
     // Let the Item's handlers (if any) have the event first.
diff --git a/src/quick/qtquickglobal_p.h b/src/quick/qtquickglobal_p.h
index 80e59563c7..97680569e7 100644
--- a/src/quick/qtquickglobal_p.h
+++ b/src/quick/qtquickglobal_p.h
@@ -62,6 +62,7 @@
 #define Q_QUICK_PRIVATE_EXPORT Q_QUICK_EXPORT
 
 void Q_QUICK_PRIVATE_EXPORT qml_register_types_QtQuick();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick);
 
 QT_BEGIN_NAMESPACE
 
diff --git a/src/quick/scenegraph/coreapi/qsgbatchrenderer.cpp b/src/quick/scenegraph/coreapi/qsgbatchrenderer.cpp
index 3b49b88182..31671c8639 100644
--- a/src/quick/scenegraph/coreapi/qsgbatchrenderer.cpp
+++ b/src/quick/scenegraph/coreapi/qsgbatchrenderer.cpp
@@ -1958,7 +1958,11 @@ void Renderer::prepareAlphaBatches()
 
             if (gni->clipList() == gnj->clipList()
                     && gni->geometry()->drawingMode() == gnj->geometry()->drawingMode()
-                    && (gni->geometry()->drawingMode() != QSGGeometry::DrawLines || gni->geometry()->lineWidth() == gnj->geometry()->lineWidth())
+                    && (gni->geometry()->drawingMode() != QSGGeometry::DrawLines
+                        || (gni->geometry()->lineWidth() == gnj->geometry()->lineWidth()
+                            // Must not do overlap checks when the line width is not 1,
+                            // we have no knowledge how such lines are rasterized.
+                            && gni->geometry()->lineWidth() == 1.0f))
                     && gni->geometry()->attributes() == gnj->geometry()->attributes()
                     && gni->inheritedOpacity() == gnj->inheritedOpacity()
                     && gni->activeMaterial()->type() == gnj->activeMaterial()->type()
@@ -2432,18 +2436,20 @@ ClipState::ClipType Renderer::updateStencilClip(const QSGClipNode *clip)
         // TODO: Check for multisampling and pixel grid alignment.
         bool isRectangleWithNoPerspective = clip->isRectangular()
                 && qFuzzyIsNull(m(3, 0)) && qFuzzyIsNull(m(3, 1));
-        auto noRotate = [] (const QMatrix4x4 &m) { return qFuzzyIsNull(m(0, 1)) && qFuzzyIsNull(m(1, 0)); };
-        auto isRotate90 = [] (const QMatrix4x4 &m) { return qFuzzyIsNull(m(0, 0)) && qFuzzyIsNull(m(1, 1)); };
-        auto scissorRect = [&] (const QRectF &bbox, const QMatrix4x4 &m) {
+        bool noRotate = qFuzzyIsNull(m(0, 1)) && qFuzzyIsNull(m(1, 0));
+        bool isRotate90 = qFuzzyIsNull(m(0, 0)) && qFuzzyIsNull(m(1, 1));
+
+        if (isRectangleWithNoPerspective && (noRotate || isRotate90)) {
+            QRectF bbox = clip->clipRect();
             qreal invW = 1 / m(3, 3);
             qreal fx1, fy1, fx2, fy2;
-            if (noRotate(m)) {
+            if (noRotate) {
                 fx1 = (bbox.left() * m(0, 0) + m(0, 3)) * invW;
                 fy1 = (bbox.bottom() * m(1, 1) + m(1, 3)) * invW;
                 fx2 = (bbox.right() * m(0, 0) + m(0, 3)) * invW;
                 fy2 = (bbox.top() * m(1, 1) + m(1, 3)) * invW;
             } else {
-                Q_ASSERT(isRotate90(m));
+                Q_ASSERT(isRotate90);
                 fx1 = (bbox.bottom() * m(0, 1) + m(0, 3)) * invW;
                 fy1 = (bbox.left() * m(1, 0) + m(1, 3)) * invW;
                 fx2 = (bbox.top() * m(0, 1) + m(0, 3)) * invW;
@@ -2462,18 +2468,12 @@ ClipState::ClipType Renderer::updateStencilClip(const QSGClipNode *clip)
             GLint ix2 = qRound((fx2 + 1) * deviceRect.width() * qreal(0.5));
             GLint iy2 = qRound((fy2 + 1) * deviceRect.height() * qreal(0.5));
 
-            return QRect(ix1, iy1, ix2 - ix1, iy2 - iy1);
-        };
-
-        if (isRectangleWithNoPerspective && (noRotate(m) || isRotate90(m))) {
-            auto rect = scissorRect(clip->clipRect(), m);
-
             if (!(clipType & ClipState::ScissorClip)) {
-                m_currentScissorRect = rect;
+                m_currentScissorRect = QRect(ix1, iy1, ix2 - ix1, iy2 - iy1);
                 glEnable(GL_SCISSOR_TEST);
                 clipType |= ClipState::ScissorClip;
             } else {
-                m_currentScissorRect &= rect;
+                m_currentScissorRect &= QRect(ix1, iy1, ix2 - ix1, iy2 - iy1);
             }
             glScissor(m_currentScissorRect.x(), m_currentScissorRect.y(),
                       m_currentScissorRect.width(), m_currentScissorRect.height());
@@ -2488,31 +2488,9 @@ ClipState::ClipType Renderer::updateStencilClip(const QSGClipNode *clip)
                     m_clipProgram.link();
                     m_clipMatrixId = m_clipProgram.uniformLocation("matrix");
                 }
-                const QSGClipNode *clipNext = clip->clipList();
-                if (clipNext) {
-                    QMatrix4x4 mNext = m_current_projection_matrix;
-                    if (clipNext->matrix())
-                        mNext *= *clipNext->matrix();
-
-                    auto rect = scissorRect(clipNext->clipRect(), mNext);
-
-                    ClipState::ClipType clipTypeNext = clipType ;
-                    clipTypeNext |= ClipState::StencilClip;
-                    QRect m_next_scissor_rect = m_currentScissorRect;
-                    if (!(clipTypeNext & ClipState::ScissorClip)) {
-                        m_next_scissor_rect = rect;
-                        glEnable(GL_SCISSOR_TEST);
-                    } else {
-                        m_next_scissor_rect =
-                           m_currentScissorRect & rect;
-                    }
-                    glScissor(m_next_scissor_rect.x(), m_next_scissor_rect.y(),
-                              m_next_scissor_rect.width(), m_next_scissor_rect.height());
-                }
 
                 glClearStencil(0);
                 glClear(GL_STENCIL_BUFFER_BIT);
-                glDisable(GL_SCISSOR_TEST);
                 glEnable(GL_STENCIL_TEST);
                 glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
                 glDepthMask(GL_FALSE);
@@ -4470,6 +4448,9 @@ void Renderer::renderRenderNode(Batch *batch) // legacy (GL-only)
         opacity = opacity->parent();
     }
 
+    // having DepthAwareRendering leaves depth test on in the alpha pass
+    const bool depthTestWasEnabled = m_useDepthBuffer;
+
     glDisable(GL_STENCIL_TEST);
     glDisable(GL_SCISSOR_TEST);
     glDisable(GL_DEPTH_TEST);
@@ -4504,7 +4485,9 @@ void Renderer::renderRenderNode(Batch *batch) // legacy (GL-only)
         m_currentClipType = ClipState::NoClip;
     }
 
-    if (changes & QSGRenderNode::DepthState)
+    if (depthTestWasEnabled)
+        glEnable(GL_DEPTH_TEST);
+    else if (changes & QSGRenderNode::DepthState)
         glDisable(GL_DEPTH_TEST);
 
     if (changes & QSGRenderNode::ColorState)
diff --git a/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp b/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp
index 3c60f830de..0fd6581dc4 100644
--- a/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp
+++ b/src/quick/scenegraph/qsgdefaultglyphnode_p.cpp
@@ -428,6 +428,18 @@ QSGTextMaskRhiShader::QSGTextMaskRhiShader(QFontEngine::GlyphFormat glyphFormat)
                       QStringLiteral(":/qt-project.org/scenegraph/shaders_ng/textmask.frag.qsb"));
 }
 
+enum UbufOffset {
+    ModelViewMatrixOffset = 0,
+    ProjectionMatrixOffset = ModelViewMatrixOffset + 64,
+    ColorOffset = ProjectionMatrixOffset + 64,
+    TextureScaleOffset = ColorOffset + 16,
+    DprOffset = TextureScaleOffset + 8,
+
+    // + 1 float padding (vec4 must be aligned to 16)
+    StyleColorOffset = DprOffset + 4 + 4,
+    ShiftOffset = StyleColorOffset + 16
+};
+
 bool QSGTextMaskRhiShader::updateUniformData(RenderState &state,
                                              QSGMaterial *newMaterial, QSGMaterial *oldMaterial)
 {
@@ -443,11 +455,14 @@ bool QSGTextMaskRhiShader::updateUniformData(RenderState &state,
 
     bool changed = false;
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 92);
+    Q_ASSERT(buf->size() >= DprOffset + 4);
 
     if (state.isMatrixDirty()) {
-        const QMatrix4x4 m = state.combinedMatrix();
-        memcpy(buf->data(), m.constData(), 64);
+        const QMatrix4x4 mv = state.modelViewMatrix();
+        memcpy(buf->data() + ModelViewMatrixOffset, mv.constData(), 64);
+        const QMatrix4x4 p = state.projectionMatrix();
+        memcpy(buf->data() + ProjectionMatrixOffset, p.constData(), 64);
+
         changed = true;
     }
 
@@ -456,13 +471,13 @@ bool QSGTextMaskRhiShader::updateUniformData(RenderState &state,
     if (updated || !oldMat || oldRtex != newRtex) {
         const QVector2D textureScale = QVector2D(1.0f / mat->rhiGlyphCache()->width(),
                                                  1.0f / mat->rhiGlyphCache()->height());
-        memcpy(buf->data() + 64 + 16, &textureScale, 8);
+        memcpy(buf->data() + TextureScaleOffset, &textureScale, 8);
         changed = true;
     }
 
     if (!oldMat) {
         float dpr = state.devicePixelRatio();
-        memcpy(buf->data() + 64 + 16 + 8, &dpr, 4);
+        memcpy(buf->data() + DprOffset, &dpr, 4);
     }
 
     // move texture uploads/copies onto the renderer's soon-to-be-committed list
@@ -510,11 +525,11 @@ bool QSG8BitTextMaskRhiShader::updateUniformData(RenderState &state,
     QSGTextMaskMaterial *oldMat = static_cast<QSGTextMaskMaterial *>(oldMaterial);
 
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 80);
+    Q_ASSERT(buf->size() >= ColorOffset + 16);
 
     if (oldMat == nullptr || mat->color() != oldMat->color() || state.isOpacityDirty()) {
         const QVector4D color = qsg_premultiply(mat->color(), state.opacity());
-        memcpy(buf->data() + 64, &color, 16);
+        memcpy(buf->data() + ColorOffset, &color, 16);
         changed = true;
     }
 
@@ -553,12 +568,12 @@ bool QSG24BitTextMaskRhiShader::updateUniformData(RenderState &state,
     QSGTextMaskMaterial *oldMat = static_cast<QSGTextMaskMaterial *>(oldMaterial);
 
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 92);
+    Q_ASSERT(buf->size() >= ColorOffset + 16);
 
     if (oldMat == nullptr || mat->color() != oldMat->color() || state.isOpacityDirty()) {
         // shader takes vec4 but uses alpha only; coloring happens via the blend constant
         const QVector4D color = qsg_premultiply(mat->color(), state.opacity());
-        memcpy(buf->data() + 64, &color, 16);
+        memcpy(buf->data() + ColorOffset, &color, 16);
         changed = true;
     }
 
@@ -608,12 +623,12 @@ bool QSG32BitColorTextRhiShader::updateUniformData(RenderState &state,
     QSGTextMaskMaterial *oldMat = static_cast<QSGTextMaskMaterial *>(oldMaterial);
 
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 92);
+    Q_ASSERT(buf->size() >= ColorOffset + 16);
 
     if (oldMat == nullptr || mat->color() != oldMat->color() || state.isOpacityDirty()) {
         // shader takes vec4 but uses alpha only
         const QVector4D color(0, 0, 0, mat->color().w() * state.opacity());
-        memcpy(buf->data() + 64, &color, 16);
+        memcpy(buf->data() + ColorOffset, &color, 16);
         changed = true;
     }
 
@@ -649,20 +664,17 @@ bool QSGStyledTextRhiShader::updateUniformData(RenderState &state,
     QSGStyledTextMaterial *oldMat = static_cast<QSGStyledTextMaterial *>(oldMaterial);
 
     QByteArray *buf = state.uniformData();
-    Q_ASSERT(buf->size() >= 120);
-
-    // matrix..dpr + 1 float padding (vec4 must be aligned to 16)
-    const int startOffset = 64 + 16 + 8 + 4 + 4;
+    Q_ASSERT(buf->size() >= ShiftOffset + 8);
 
     if (oldMat == nullptr || mat->styleColor() != oldMat->styleColor() || state.isOpacityDirty()) {
         const QVector4D styleColor = qsg_premultiply(mat->styleColor(), state.opacity());
-        memcpy(buf->data() + startOffset, &styleColor, 16);
+        memcpy(buf->data() + StyleColorOffset, &styleColor, 16);
         changed = true;
     }
 
     if (oldMat == nullptr || oldMat->styleShift() != mat->styleShift()) {
         const QVector2D v = mat->styleShift();
-        memcpy(buf->data() + startOffset + 16, &v, 8);
+        memcpy(buf->data() + ShiftOffset, &v, 8);
         changed = true;
     }
 
diff --git a/src/quick/scenegraph/shaders_ng/24bittextmask.frag b/src/quick/scenegraph/shaders_ng/24bittextmask.frag
index bc3826a924..ed8da4cd30 100644
--- a/src/quick/scenegraph/shaders_ng/24bittextmask.frag
+++ b/src/quick/scenegraph/shaders_ng/24bittextmask.frag
@@ -6,8 +6,9 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
-    vec4 color; // only alpha is used, but must be vec4 due to layout compat
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
+    vec4 color;
     vec2 textureScale;
     float dpr;
 } ubuf;
diff --git a/src/quick/scenegraph/shaders_ng/32bitcolortext.frag b/src/quick/scenegraph/shaders_ng/32bitcolortext.frag
index 63e445f90b..4198a4d339 100644
--- a/src/quick/scenegraph/shaders_ng/32bitcolortext.frag
+++ b/src/quick/scenegraph/shaders_ng/32bitcolortext.frag
@@ -6,8 +6,9 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
-    vec4 color; // only alpha is used, but must be vec4 due to layout compat
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
+    vec4 color;
     vec2 textureScale;
     float dpr;
 } ubuf;
diff --git a/src/quick/scenegraph/shaders_ng/8bittextmask.frag b/src/quick/scenegraph/shaders_ng/8bittextmask.frag
index 6304e821ff..a06743876d 100644
--- a/src/quick/scenegraph/shaders_ng/8bittextmask.frag
+++ b/src/quick/scenegraph/shaders_ng/8bittextmask.frag
@@ -6,7 +6,8 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff --git a/src/quick/scenegraph/shaders_ng/8bittextmask_a.frag b/src/quick/scenegraph/shaders_ng/8bittextmask_a.frag
index 0d0fa1cd3a..f725cbc5e7 100644
--- a/src/quick/scenegraph/shaders_ng/8bittextmask_a.frag
+++ b/src/quick/scenegraph/shaders_ng/8bittextmask_a.frag
@@ -6,7 +6,8 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff --git a/src/quick/scenegraph/shaders_ng/outlinedtext.frag b/src/quick/scenegraph/shaders_ng/outlinedtext.frag
index 947d161a50..e2f82d3845 100644
--- a/src/quick/scenegraph/shaders_ng/outlinedtext.frag
+++ b/src/quick/scenegraph/shaders_ng/outlinedtext.frag
@@ -11,11 +11,12 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    // must match styledtext
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
+    // the above must stay compatible with textmask/8bittextmask
     vec4 styleColor;
     vec2 shift;
 } ubuf;
diff --git a/src/quick/scenegraph/shaders_ng/outlinedtext.vert b/src/quick/scenegraph/shaders_ng/outlinedtext.vert
index 023f9dfdc2..4068e42f28 100644
--- a/src/quick/scenegraph/shaders_ng/outlinedtext.vert
+++ b/src/quick/scenegraph/shaders_ng/outlinedtext.vert
@@ -10,11 +10,12 @@ layout(location = 3) out vec2 sCoordLeft;
 layout(location = 4) out vec2 sCoordRight;
 
 layout(std140, binding = 0) uniform buf {
-    // must match styledtext
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
+    // the above must stay compatible with textmask/8bittextmask
     vec4 styleColor;
     vec2 shift;
 } ubuf;
@@ -28,6 +29,6 @@ void main()
      sCoordDown = (tCoord - vec2(0.0, 1.0)) * ubuf.textureScale;
      sCoordLeft = (tCoord - vec2(-1.0, 0.0)) * ubuf.textureScale;
      sCoordRight = (tCoord - vec2(1.0, 0.0)) * ubuf.textureScale;
-     vec3 dprSnapPos = floor(vCoord.xyz * ubuf.dpr + 0.5) / ubuf.dpr;
-     gl_Position = ubuf.matrix * vec4(dprSnapPos, vCoord.w);
+     vec4 xformed = ubuf.modelViewMatrix * vCoord;
+     gl_Position = ubuf.projectionMatrix * vec4(floor(xformed.xyz * ubuf.dpr + 0.5) / ubuf.dpr, xformed.w);
 }
diff --git a/src/quick/scenegraph/shaders_ng/outlinedtext_a.frag b/src/quick/scenegraph/shaders_ng/outlinedtext_a.frag
index 5b7bd9ca82..274d891a3c 100644
--- a/src/quick/scenegraph/shaders_ng/outlinedtext_a.frag
+++ b/src/quick/scenegraph/shaders_ng/outlinedtext_a.frag
@@ -11,11 +11,12 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    // must match styledtext
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
+    // the above must stay compatible with textmask/8bittextmask
     vec4 styleColor;
     vec2 shift;
 } ubuf;
diff --git a/src/quick/scenegraph/shaders_ng/styledtext.frag b/src/quick/scenegraph/shaders_ng/styledtext.frag
index 0b16396037..2e380dfeae 100644
--- a/src/quick/scenegraph/shaders_ng/styledtext.frag
+++ b/src/quick/scenegraph/shaders_ng/styledtext.frag
@@ -8,7 +8,8 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff --git a/src/quick/scenegraph/shaders_ng/styledtext.vert b/src/quick/scenegraph/shaders_ng/styledtext.vert
index beadf07c79..271dae8d8a 100644
--- a/src/quick/scenegraph/shaders_ng/styledtext.vert
+++ b/src/quick/scenegraph/shaders_ng/styledtext.vert
@@ -7,7 +7,8 @@ layout(location = 0) out vec2 sampleCoord;
 layout(location = 1) out vec2 shiftedSampleCoord;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
@@ -22,6 +23,6 @@ void main()
 {
      sampleCoord = tCoord * ubuf.textureScale;
      shiftedSampleCoord = (tCoord - ubuf.shift) * ubuf.textureScale;
-     vec3 dprSnapPos = floor(vCoord.xyz * ubuf.dpr + 0.5) / ubuf.dpr;
-     gl_Position = ubuf.matrix * vec4(dprSnapPos, vCoord.w);
+     vec4 xformed = ubuf.modelViewMatrix * vCoord;
+     gl_Position = ubuf.projectionMatrix * vec4(floor(xformed.xyz * ubuf.dpr + 0.5) / ubuf.dpr, xformed.w);
 }
diff --git a/src/quick/scenegraph/shaders_ng/styledtext_a.frag b/src/quick/scenegraph/shaders_ng/styledtext_a.frag
index b673137895..62e162c851 100644
--- a/src/quick/scenegraph/shaders_ng/styledtext_a.frag
+++ b/src/quick/scenegraph/shaders_ng/styledtext_a.frag
@@ -8,7 +8,8 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff --git a/src/quick/scenegraph/shaders_ng/textmask.frag b/src/quick/scenegraph/shaders_ng/textmask.frag
index 518d5c965f..ed8da4cd30 100644
--- a/src/quick/scenegraph/shaders_ng/textmask.frag
+++ b/src/quick/scenegraph/shaders_ng/textmask.frag
@@ -6,7 +6,8 @@ layout(location = 0) out vec4 fragColor;
 layout(binding = 1) uniform sampler2D _qt_texture;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
diff --git a/src/quick/scenegraph/shaders_ng/textmask.vert b/src/quick/scenegraph/shaders_ng/textmask.vert
index 9d80d5dadb..e0b3c01bce 100644
--- a/src/quick/scenegraph/shaders_ng/textmask.vert
+++ b/src/quick/scenegraph/shaders_ng/textmask.vert
@@ -6,7 +6,8 @@ layout(location = 1) in vec2 tCoord;
 layout(location = 0) out vec2 sampleCoord;
 
 layout(std140, binding = 0) uniform buf {
-    mat4 matrix;
+    mat4 modelViewMatrix;
+    mat4 projectionMatrix;
     vec4 color;
     vec2 textureScale;
     float dpr;
@@ -17,6 +18,6 @@ out gl_PerVertex { vec4 gl_Position; };
 void main()
 {
      sampleCoord = tCoord * ubuf.textureScale;
-     vec3 dprSnapPos = floor(vCoord.xyz * ubuf.dpr + 0.5) / ubuf.dpr;
-     gl_Position = ubuf.matrix * vec4(dprSnapPos, vCoord.w);
+     vec4 xformed = ubuf.modelViewMatrix * vCoord;
+     gl_Position = ubuf.projectionMatrix * vec4(floor(xformed.xyz * ubuf.dpr + 0.5) / ubuf.dpr, xformed.w);
 }
diff --git a/src/quick/util/qquickshortcut.cpp b/src/quick/util/qquickshortcut.cpp
index 8e135b4624..fee8382766 100644
--- a/src/quick/util/qquickshortcut.cpp
+++ b/src/quick/util/qquickshortcut.cpp
@@ -44,6 +44,7 @@
 #include <QtQuick/qquickrendercontrol.h>
 #include <QtQuick/private/qtquickglobal_p.h>
 #include <QtGui/private/qguiapplication_p.h>
+#include <QtQml/qqmlinfo.h>
 
 /*!
     \qmltype Shortcut
@@ -124,13 +125,35 @@ Q_QUICK_PRIVATE_EXPORT void qt_quick_set_shortcut_context_matcher(ContextMatcher
 
 QT_BEGIN_NAMESPACE
 
-static QKeySequence valueToKeySequence(const QVariant &value)
+static QKeySequence valueToKeySequence(const QVariant &value, const QQuickShortcut *const shortcut)
 {
-    if (value.userType() == QMetaType::Int)
-        return QKeySequence(static_cast<QKeySequence::StandardKey>(value.toInt()));
+    if (value.userType() == QMetaType::Int) {
+        const QList<QKeySequence> s =
+                QKeySequence::keyBindings(static_cast<QKeySequence::StandardKey>(value.toInt()));
+        if (s.size() > 1) {
+            const QString templateString = QString::fromUtf16(
+                    u"Shortcut: Only binding to one of multiple key bindings associated with %1. "
+                    u"Use 'sequences: [ <key> ]' to bind to all of them.");
+            qmlWarning(shortcut)
+                    << templateString.arg(static_cast<QKeySequence::StandardKey>(value.toInt()));
+        }
+        return s.size() > 0 ? s[0] : QKeySequence {};
+    }
+
     return QKeySequence::fromString(value.toString());
 }
 
+static QList<QKeySequence> valueToKeySequences(const QVariant &value)
+{
+    if (value.userType() == QMetaType::Int) {
+        return QKeySequence::keyBindings(static_cast<QKeySequence::StandardKey>(value.toInt()));
+    } else {
+        QList<QKeySequence> result;
+        result.push_back(QKeySequence::fromString(value.toString()));
+        return result;
+    }
+}
+
 QQuickShortcut::QQuickShortcut(QObject *parent) : QObject(parent),
     m_enabled(true), m_completed(false), m_autorepeat(true), m_context(Qt::WindowShortcut)
 {
@@ -172,7 +195,7 @@ void QQuickShortcut::setSequence(const QVariant &value)
     if (value == m_shortcut.userValue)
         return;
 
-    QKeySequence keySequence = valueToKeySequence(value);
+    QKeySequence keySequence = valueToKeySequence(value, this);
 
     ungrabShortcut(m_shortcut);
     m_shortcut.userValue = value;
@@ -207,28 +230,42 @@ QVariantList QQuickShortcut::sequences() const
 
 void QQuickShortcut::setSequences(const QVariantList &values)
 {
-    QVector<Shortcut> remainder = m_shortcuts.mid(values.count());
-    m_shortcuts.resize(values.count());
-
-    bool changed = !remainder.isEmpty();
-    for (int i = 0; i < values.count(); ++i) {
-        const QVariant &value = values.at(i);
-        Shortcut& shortcut = m_shortcuts[i];
-        if (value == shortcut.userValue)
-            continue;
-
-        QKeySequence keySequence = valueToKeySequence(value);
-
-        ungrabShortcut(shortcut);
-        shortcut.userValue = value;
-        shortcut.keySequence = keySequence;
-        grabShortcut(shortcut, m_context);
+    // convert QVariantList to QVector<Shortcut>
+    QVector<Shortcut> requestedShortcuts;
+    for (const QVariant &v : values) {
+        const QList<QKeySequence> list = valueToKeySequences(v);
+        for (const QKeySequence &s : list) {
+            Shortcut sc;
+            sc.userValue = v;
+            sc.keySequence = s;
+            requestedShortcuts.push_back(sc);
+        }
+    }
 
-        changed = true;
+    // if nothing has changed, just return:
+    if (m_shortcuts.size() == requestedShortcuts.size()) {
+        bool changed = false;
+        for (int i = 0; i < requestedShortcuts.count(); ++i) {
+            const Shortcut &requestedShortcut = requestedShortcuts[i];
+            const Shortcut &shortcut = m_shortcuts[i];
+            if (!(requestedShortcut.userValue == shortcut.userValue
+                  && requestedShortcut.keySequence == shortcut.keySequence)) {
+                changed = true;
+                break;
+            }
+        }
+        if (!changed) {
+            return;
+        }
     }
 
-    if (changed)
-        emit sequencesChanged();
+    for (Shortcut &s : m_shortcuts)
+        ungrabShortcut(s);
+    m_shortcuts = requestedShortcuts;
+    for (Shortcut &s : m_shortcuts)
+        grabShortcut(s, m_context);
+
+    emit sequencesChanged();
 }
 
 /*!
@@ -342,8 +379,15 @@ void QQuickShortcut::setContext(Qt::ShortcutContext context)
         return;
 
     ungrabShortcut(m_shortcut);
+    for (auto &s : m_shortcuts)
+        ungrabShortcut(s);
+
     m_context = context;
+
     grabShortcut(m_shortcut, context);
+    for (auto &s : m_shortcuts)
+        grabShortcut(s, context);
+
     emit contextChanged();
 }
 
diff --git a/src/quick/util/qquickstate.cpp b/src/quick/util/qquickstate.cpp
index 71ab1f4d62..6a72754bde 100644
--- a/src/quick/util/qquickstate.cpp
+++ b/src/quick/util/qquickstate.cpp
@@ -635,6 +635,11 @@ void QQuickState::apply(QQuickTransition *trans, QQuickState *revert)
             }
         }
         if (!found) {
+            // If revert list contains bindings assigned to deleted objects, we need to
+            // prevent reverting properties of those objects.
+            if (d->revertList.at(ii).binding() && !d->revertList.at(ii).property().object()) {
+                continue;
+            }
             QVariant cur = d->revertList.at(ii).property().read();
             QQmlPropertyPrivate::removeBinding(d->revertList.at(ii).property());
 
diff --git a/src/quick/util/qquickstyledtext.cpp b/src/quick/util/qquickstyledtext.cpp
index 660852ba83..a25af90414 100644
--- a/src/quick/util/qquickstyledtext.cpp
+++ b/src/quick/util/qquickstyledtext.cpp
@@ -46,6 +46,8 @@
 #include "qquickstyledtext_p.h"
 #include <QQmlContext>
 
+Q_LOGGING_CATEGORY(lcStyledText, "qt.quick.styledtext")
+
 /*
     QQuickStyledText supports few tags:
 
@@ -562,10 +564,14 @@ void QQuickStyledTextPrivate::parseEntity(const QChar *&ch, const QString &textI
                 textOut += QChar(60);
             else if (entity == QLatin1String("amp"))
                 textOut += QChar(38);
+            else if (entity == QLatin1String("apos"))
+                textOut += QChar(39);
             else if (entity == QLatin1String("quot"))
                 textOut += QChar(34);
             else if (entity == QLatin1String("nbsp"))
                 textOut += QChar(QChar::Nbsp);
+            else
+                qCWarning(lcStyledText) << "StyledText doesn't support entity" << entity;
             return;
         } else if (*ch == QLatin1Char(' ')) {
             QStringRef entity(&textIn, entityStart - 1, entityLength + 1);
diff --git a/src/quickshapes/qquickshapegenericrenderer.cpp b/src/quickshapes/qquickshapegenericrenderer.cpp
index e9bc715952..289dee1081 100644
--- a/src/quickshapes/qquickshapegenericrenderer.cpp
+++ b/src/quickshapes/qquickshapegenericrenderer.cpp
@@ -204,8 +204,12 @@ void QQuickShapeGenericRenderer::setStrokeWidth(int index, qreal w)
 void QQuickShapeGenericRenderer::setFillColor(int index, const QColor &color)
 {
     ShapePathData &d(m_sp[index]);
+    const bool wasTransparent = d.fillColor.a == 0;
     d.fillColor = colorToColor4ub(color);
+    const bool isTransparent = d.fillColor.a == 0;
     d.syncDirty |= DirtyColor;
+    if (wasTransparent && !isTransparent)
+        d.syncDirty |= DirtyFillGeom;
 }
 
 void QQuickShapeGenericRenderer::setFillRule(int index, QQuickShapePath::FillRule fillRule)
diff --git a/src/quickshapes/qquickshapesglobal_p.h b/src/quickshapes/qquickshapesglobal_p.h
index 40f6cfbdcf..37386c23b2 100644
--- a/src/quickshapes/qquickshapesglobal_p.h
+++ b/src/quickshapes/qquickshapesglobal_p.h
@@ -51,6 +51,7 @@
 // We mean it.
 //
 
+#include <QtQml/qqmlextensionplugin.h>
 #include "qquickshapesglobal.h"
 
 QT_BEGIN_NAMESPACE
@@ -60,5 +61,6 @@ QT_BEGIN_NAMESPACE
 QT_END_NAMESPACE
 
 void Q_QUICKSHAPES_PRIVATE_EXPORT qml_register_types_QtQuick_Shapes();
+GHS_KEEP_REFERENCE(qml_register_types_QtQuick_Shapes);
 
 #endif // QQUICKSHAPESGLOBAL_P_H
diff --git a/src/quickwidgets/qquickwidget.cpp b/src/quickwidgets/qquickwidget.cpp
index 39780f8de3..223d91f579 100644
--- a/src/quickwidgets/qquickwidget.cpp
+++ b/src/quickwidgets/qquickwidget.cpp
@@ -106,6 +106,7 @@ void QQuickWidgetPrivate::init(QQmlEngine* e)
 
     renderControl = new QQuickWidgetRenderControl(q);
     offscreenWindow = new QQuickWindow(*new QQuickOffcreenWindowPrivate(),renderControl);
+    offscreenWindow->setScreen(q->screen());
     offscreenWindow->setTitle(QString::fromLatin1("Offscreen"));
     offscreenWindow->setObjectName(QString::fromLatin1("QQuickOffScreenWindow"));
     // Do not call create() on offscreenWindow.
@@ -901,9 +902,7 @@ void QQuickWidgetPrivate::createContext()
 
         context = new QOpenGLContext;
         context->setFormat(offscreenWindow->requestedFormat());
-        const QWindow *win = q->window()->windowHandle();
-        if (win && win->screen())
-            context->setScreen(win->screen());
+        context->setScreen(q->screen());
         QOpenGLContext *shareContext = qt_gl_global_share_context();
         if (!shareContext)
             shareContext = QWidgetPrivate::get(q->window())->shareContext();
@@ -1520,19 +1519,16 @@ bool QQuickWidget::event(QEvent *e)
         d->handleWindowChange();
         break;
 
-    case QEvent::ScreenChangeInternal:
-        if (QWindow *window = this->window()->windowHandle()) {
-            QScreen *newScreen = window->screen();
-
-            if (d->offscreenWindow)
-                d->offscreenWindow->setScreen(newScreen);
-            if (d->offscreenSurface)
-                d->offscreenSurface->setScreen(newScreen);
+    case QEvent::ScreenChangeInternal: {
+        QScreen *newScreen = screen();
+        if (d->offscreenWindow)
+            d->offscreenWindow->setScreen(newScreen);
+        if (d->offscreenSurface)
+            d->offscreenSurface->setScreen(newScreen);
 #if QT_CONFIG(opengl)
-            if (d->context)
-                d->context->setScreen(newScreen);
+        if (d->context)
+            d->context->setScreen(newScreen);
 #endif
-        }
 
         if (d->useSoftwareRenderer
 #if QT_CONFIG(opengl)
@@ -1545,7 +1541,7 @@ bool QQuickWidget::event(QEvent *e)
             d->render(true);
         }
         break;
-
+    }
     case QEvent::Show:
     case QEvent::Move:
         d->updatePosition();
diff --git a/tests/auto/particles/qquickitemparticle/data/takeGive.qml b/tests/auto/particles/qquickitemparticle/data/takeGive.qml
index e95ae738bd..926d83bfc1 100644
--- a/tests/auto/particles/qquickitemparticle/data/takeGive.qml
+++ b/tests/auto/particles/qquickitemparticle/data/takeGive.qml
@@ -65,9 +65,10 @@ Rectangle {
         }
 
         Emitter{
+            objectName: "emitter"
             //0,0 position
             size: 32
-            emitRate: 1000
+            emitRate: 0
             lifeSpan: Emitter.InfiniteLife
         }
     }
diff --git a/tests/auto/particles/qquickitemparticle/tst_qquickitemparticle.cpp b/tests/auto/particles/qquickitemparticle/tst_qquickitemparticle.cpp
index 28ebbb3c05..538c429d1a 100644
--- a/tests/auto/particles/qquickitemparticle/tst_qquickitemparticle.cpp
+++ b/tests/auto/particles/qquickitemparticle/tst_qquickitemparticle.cpp
@@ -29,6 +29,7 @@
 #include <QtTest/QtTest>
 #include "../shared/particlestestsshared.h"
 #include <private/qquickparticlesystem_p.h>
+#include <private/qquickparticleemitter_p.h>
 #include <private/qquickimage_p.h>
 #include <private/qabstractanimation_p.h>
 
@@ -114,11 +115,14 @@ void tst_qquickitemparticle::test_takeGive()
 {
     QQuickView* view = createView(testFileUrl("takeGive.qml"), 500);
     QQuickParticleSystem* system = view->rootObject()->findChild<QQuickParticleSystem*>("system");
+    QQuickParticleEmitter* emitter = view->rootObject()->findChild<QQuickParticleEmitter*>("emitter");
     QMetaObject::invokeMethod(view->rootObject(), "takeItems");
+    emitter->burst(100);
     ensureAnimTime(1000, system->m_animation);
     QVERIFY(system->property("acc").toInt() == 100);
     QMetaObject::invokeMethod(view->rootObject(), "giveItems");
     QTRY_VERIFY(system->property("acc").toInt() == 0);
+    QTRY_VERIFY(system->isEmpty() == true);
     delete view;
 }
 
diff --git a/tests/auto/qml/animation/qsequentialanimationgroupjob/tst_qsequentialanimationgroupjob.cpp b/tests/auto/qml/animation/qsequentialanimationgroupjob/tst_qsequentialanimationgroupjob.cpp
index 57b0905a8a..150734496e 100644
--- a/tests/auto/qml/animation/qsequentialanimationgroupjob/tst_qsequentialanimationgroupjob.cpp
+++ b/tests/auto/qml/animation/qsequentialanimationgroupjob/tst_qsequentialanimationgroupjob.cpp
@@ -68,6 +68,7 @@ private slots:
     void insertAnimation();
     void clear();
     void pauseResume();
+    void deleteFromListener();
 };
 
 void tst_QSequentialAnimationGroupJob::initTestCase()
@@ -126,15 +127,23 @@ protected:
 class StateChangeListener: public QAnimationJobChangeListener
 {
 public:
-    virtual void animationStateChanged(QAbstractAnimationJob *, QAbstractAnimationJob::State newState, QAbstractAnimationJob::State)
+    virtual void animationStateChanged(
+            QAbstractAnimationJob *job, QAbstractAnimationJob::State newState,
+            QAbstractAnimationJob::State)
     {
         states << newState;
+        if (beEvil) {
+            delete job->group();
+            groupDeleted = true;
+        }
     }
 
     void clear() { states.clear(); }
     int count() const { return states.count(); }
 
     QList<QAbstractAnimationJob::State> states;
+    bool beEvil = false;
+    bool groupDeleted = false;
 };
 
 class FinishedListener: public QAnimationJobChangeListener
@@ -1644,6 +1653,37 @@ void tst_QSequentialAnimationGroupJob::uncontrolledWithLoops()
     QTRY_COMPARE(group.state(), QAbstractAnimationJob::Stopped);
 }
 
+void tst_QSequentialAnimationGroupJob::deleteFromListener()
+{
+    QSequentialAnimationGroupJob *group = new QSequentialAnimationGroupJob;
+
+    UncontrolledAnimation *uncontrolled = new UncontrolledAnimation();
+    TestAnimation *shortLoop = new TestAnimation(100);
+    UncontrolledAnimation *more = new UncontrolledAnimation();
+
+    shortLoop->setLoopCount(-1);
+
+    group->appendAnimation(uncontrolled);
+    group->appendAnimation(shortLoop);
+    group->appendAnimation(more);
+
+    StateChangeListener listener;
+    listener.beEvil = true;
+    shortLoop->addAnimationChangeListener(&listener, QAbstractAnimationJob::StateChange);
+    group->setLoopCount(2);
+
+    group->start();
+
+    QCOMPARE(group->currentLoop(), 0);
+    QCOMPARE(group->state(), QAbstractAnimationJob::Running);
+    QTRY_COMPARE(uncontrolled->state(), QAbstractAnimationJob::Running);
+
+    QVERIFY(!listener.groupDeleted);
+    uncontrolled->stop();
+
+    QTRY_VERIFY(listener.groupDeleted);
+    // It's dead, Jim.
+}
 
 QTEST_MAIN(tst_QSequentialAnimationGroupJob)
 #include "tst_qsequentialanimationgroupjob.moc"
diff --git a/tests/auto/qml/debugger/qv4debugger/tst_qv4debugger.cpp b/tests/auto/qml/debugger/qv4debugger/tst_qv4debugger.cpp
index 84f5eebd10..e3cbeb9891 100644
--- a/tests/auto/qml/debugger/qv4debugger/tst_qv4debugger.cpp
+++ b/tests/auto/qml/debugger/qv4debugger/tst_qv4debugger.cpp
@@ -910,19 +910,25 @@ void tst_qv4debugger::signalParameters()
     component.setData("import QtQml 2.12\n"
                       "QtObject {\n"
                       "    id: root\n"
-                      "    property string result\n"
+                      "    property string result: 'unset'\n"
+                      "    property string resultCallbackInternal: 'unset'\n"
+                      "    property string resultCallbackExternal: 'unset'\n"
                       "    signal signalWithArg(string textArg)\n"
+                      "    function call(callback) { callback(); }\n"
+                      "    function externalCallback() { root.resultCallbackExternal = textArg; }\n"
                       "    property Connections connections : Connections {\n"
                       "        target: root\n"
-                      "        onSignalWithArg: { root.result = textArg; }\n"
+                      "        onSignalWithArg: { root.result = textArg; call(function() { root.resultCallbackInternal = textArg; }); call(externalCallback); }\n"
                       "    }\n"
                       "    Component.onCompleted: signalWithArg('something')\n"
                       "}", QUrl("test.qml"));
 
-    QVERIFY(component.isReady());
+    QVERIFY2(component.isReady(), qPrintable(component.errorString()));
     QScopedPointer<QObject> obj(component.create());
     QVERIFY(obj);
     QCOMPARE(obj->property("result").toString(), QLatin1String("something"));
+    QCOMPARE(obj->property("resultCallbackInternal").toString(), QLatin1String("something"));
+    QCOMPARE(obj->property("resultCallbackExternal").toString(), QLatin1String("unset"));
 }
 
 QTEST_MAIN(tst_qv4debugger)
diff --git a/tests/auto/qml/ecmascripttests/testcase.pro b/tests/auto/qml/ecmascripttests/testcase.pro
index 5bf7ecd696..3af1adf9c9 100644
--- a/tests/auto/qml/ecmascripttests/testcase.pro
+++ b/tests/auto/qml/ecmascripttests/testcase.pro
@@ -11,5 +11,5 @@ DEFINES += SRCDIR=\\\"$$PWD\\\"
 # test some of the time.  Fix by raising time-out to 400s when
 # invoking tst_ecmascripttests:
 checkenv.name = QTEST_FUNCTION_TIMEOUT
-checkenv.value = 500000
+checkenv.value = 1000000
 QT_TOOL_ENV += checkenv
diff --git a/tests/auto/qml/qjsengine/tst_qjsengine.cpp b/tests/auto/qml/qjsengine/tst_qjsengine.cpp
index 3b7d74df63..b75bf820d5 100644
--- a/tests/auto/qml/qjsengine/tst_qjsengine.cpp
+++ b/tests/auto/qml/qjsengine/tst_qjsengine.cpp
@@ -102,6 +102,7 @@ private slots:
     void valueConversion_RegularExpression();
     void castWithMultipleInheritance();
     void collectGarbage();
+    void collectGarbageNestedWrappersTwoEngines();
     void gcWithNestedDataStructure();
     void stacktrace();
     void numberParsing_data();
@@ -1809,6 +1810,44 @@ void tst_QJSEngine::collectGarbage()
     QVERIFY(ptr.isNull());
 }
 
+class TestObjectContainer : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QObject *dummy MEMBER m_dummy CONSTANT)
+
+public:
+    TestObjectContainer() : m_dummy(new QObject(this)) {}
+
+private:
+    QObject *m_dummy;
+};
+
+void tst_QJSEngine::collectGarbageNestedWrappersTwoEngines()
+{
+    QJSEngine engine1;
+    QJSEngine engine2;
+
+    TestObjectContainer container;
+    QQmlEngine::setObjectOwnership(&container, QQmlEngine::CppOwnership);
+
+    engine1.globalObject().setProperty("foobar", engine1.newQObject(&container));
+    engine2.globalObject().setProperty("foobar", engine2.newQObject(&container));
+
+    engine1.evaluate("foobar.dummy.baz = 42");
+    engine2.evaluate("foobar.dummy.baz = 43");
+
+    QCOMPARE(engine1.evaluate("foobar.dummy.baz").toInt(), 42);
+    QCOMPARE(engine2.evaluate("foobar.dummy.baz").toInt(), 43);
+
+    engine1.collectGarbage();
+    engine2.collectGarbage();
+
+    // The GC should not collect dummy object wrappers neither in engine1 nor engine2, we
+    // verify that by checking whether the baz property still has its previous value.
+    QCOMPARE(engine1.evaluate("foobar.dummy.baz").toInt(), 42);
+    QCOMPARE(engine2.evaluate("foobar.dummy.baz").toInt(), 43);
+}
+
 void tst_QJSEngine::gcWithNestedDataStructure()
 {
     // The GC must be able to traverse deeply nested objects, otherwise this
diff --git a/tests/auto/qml/qmlcachegen/data/posthocrequired.qml b/tests/auto/qml/qmlcachegen/data/posthocrequired.qml
new file mode 100644
index 0000000000..3b32d9fe8f
--- /dev/null
+++ b/tests/auto/qml/qmlcachegen/data/posthocrequired.qml
@@ -0,0 +1,5 @@
+import QtQuick 2.15
+
+Item {
+    required x
+}
diff --git a/tests/auto/qml/qmlcachegen/tst_qmlcachegen.cpp b/tests/auto/qml/qmlcachegen/tst_qmlcachegen.cpp
index c5602eda7d..3810f505b3 100644
--- a/tests/auto/qml/qmlcachegen/tst_qmlcachegen.cpp
+++ b/tests/auto/qml/qmlcachegen/tst_qmlcachegen.cpp
@@ -77,6 +77,7 @@ private slots:
 
     void parameterAdjustment();
     void inlineComponent();
+    void posthocRequired();
 };
 
 // A wrapper around QQmlComponent to ensure the temporary reference counts
@@ -701,6 +702,17 @@ void tst_qmlcachegen::inlineComponent()
     QVERIFY(!obj.isNull());
 }
 
+void tst_qmlcachegen::posthocRequired()
+{
+    bool ok = generateCache(testFile("posthocrequired.qml"));
+    QVERIFY(ok);
+    QQmlEngine engine;
+    CleanlyLoadingComponent component(&engine, testFileUrl("posthocrequired.qml"));
+    QScopedPointer<QObject> obj(component.create());
+    QVERIFY(obj.isNull() && component.isError());
+    QVERIFY(component.errorString().contains(QStringLiteral("Required property x was not initialized")));
+}
+
 QTEST_GUILESS_MAIN(tst_qmlcachegen)
 
 #include "tst_qmlcachegen.moc"
diff --git a/tests/auto/qml/qmldiskcache/tst_qmldiskcache.cpp b/tests/auto/qml/qmldiskcache/tst_qmldiskcache.cpp
index d0c8390a74..3c59f7bd56 100644
--- a/tests/auto/qml/qmldiskcache/tst_qmldiskcache.cpp
+++ b/tests/auto/qml/qmldiskcache/tst_qmldiskcache.cpp
@@ -64,6 +64,7 @@ private slots:
     void singletonDependency();
     void cppRegisteredSingletonDependency();
     void cacheModuleScripts();
+    void reuseStaticMappings();
 
 private:
     QDir m_qmlCacheDirectory;
@@ -127,34 +128,43 @@ struct TestCompiler
         mappedFile.setFileName(cacheFilePath);
     }
 
-    bool compile(const QByteArray &contents)
+    void reset()
     {
         closeMapping();
         engine->clearComponentCache();
-
         waitForFileSystem();
+    }
 
-        {
-            QFile f(testFilePath);
-            if (!f.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
-                lastErrorString = f.errorString();
-                return false;
-            }
-            if (f.write(contents) != contents.size()) {
-                lastErrorString = f.errorString();
-                return false;
-            }
+    bool writeTestFile(const QByteArray &contents)
+    {
+        QFile f(testFilePath);
+        if (!f.open(QIODevice::WriteOnly | QIODevice::Truncate)) {
+            lastErrorString = f.errorString();
+            return false;
+        }
+        if (f.write(contents) != contents.size()) {
+            lastErrorString = f.errorString();
+            return false;
         }
+        return true;
+    }
 
+    bool loadTestFile()
+    {
         CleanlyLoadingComponent component(engine, testFilePath);
         if (!component.isReady()) {
             lastErrorString = component.errorString();
             return false;
         }
-
         return true;
     }
 
+    bool compile(const QByteArray &contents)
+    {
+        reset();
+        return writeTestFile(contents) && loadTestFile();
+    }
+
     const QV4::CompiledData::Unit *mapUnit()
     {
         if (!mappedFile.open(QIODevice::ReadOnly)) {
@@ -173,29 +183,62 @@ struct TestCompiler
     }
 
     typedef void (*HeaderTweakFunction)(QV4::CompiledData::Unit *header);
-    bool tweakHeader(HeaderTweakFunction function)
+    bool tweakHeader(HeaderTweakFunction function, const QString &newName)
     {
         closeMapping();
 
-        QFile f(cacheFilePath);
-        if (!f.open(QIODevice::ReadWrite))
+        const QString targetTestFilePath = tempDir.path() + "/" + newName;
+
+        {
+            QFile testFile(testFilePath);
+            if (!testFile.copy(targetTestFilePath))
+                return false;
+        }
+
+        const QString targetCacheFilePath = QV4::ExecutableCompilationUnit::localCacheFilePath(
+                    QUrl::fromLocalFile(targetTestFilePath));
+
+        QFile source(cacheFilePath);
+        if (!source.copy(targetCacheFilePath))
             return false;
+
+        if (!source.open(QIODevice::ReadOnly))
+            return false;
+
+        QFile target(targetCacheFilePath);
+        if (!target.open(QIODevice::WriteOnly))
+            return false;
+
         QV4::CompiledData::Unit header;
-        if (f.read(reinterpret_cast<char *>(&header), sizeof(header)) != sizeof(header))
+        if (source.read(reinterpret_cast<char *>(&header), sizeof(header)) != sizeof(header))
             return false;
         function(&header);
-        f.seek(0);
-        return f.write(reinterpret_cast<const char *>(&header), sizeof(header)) == sizeof(header);
+
+        return target.write(reinterpret_cast<const char *>(&header), sizeof(header))
+                == sizeof(header);
     }
 
-    bool verify()
+    bool verify(const QString &fileName = QString())
+    {
+        const QString path = fileName.isEmpty() ? testFilePath : tempDir.path() + "/" + fileName;
+
+        QQmlRefPointer<QV4::ExecutableCompilationUnit> unit
+                = QV4::ExecutableCompilationUnit::create();
+        return unit->loadFromDisk(QUrl::fromLocalFile(path),
+                                  QFileInfo(path).lastModified(), &lastErrorString);
+    }
+
+    quintptr unitData()
     {
         QQmlRefPointer<QV4::ExecutableCompilationUnit> unit
                 = QV4::ExecutableCompilationUnit::create();
         return unit->loadFromDisk(QUrl::fromLocalFile(testFilePath),
-                                  QFileInfo(testFilePath).lastModified(), &lastErrorString);
+                                  QFileInfo(testFilePath).lastModified(), &lastErrorString)
+                ? quintptr(unit->unitData())
+                : 0;
     }
 
+
     void closeMapping()
     {
         if (currentMapping) {
@@ -205,10 +248,11 @@ struct TestCompiler
         mappedFile.close();
     }
 
-    void clearCache()
+    void clearCache(const QString &fileName = QString())
     {
+        const QString path = fileName.isEmpty() ? testFilePath : tempDir.path() + "/" + fileName;
         closeMapping();
-        QFile::remove(cacheFilePath);
+        QFile::remove(path);
     }
 
     QQmlEngine *engine;
@@ -404,25 +448,28 @@ void tst_qmldiskcache::basicVersionChecks()
         testCompiler.clearCache();
         QVERIFY2(testCompiler.compile(contents), qPrintable(testCompiler.lastErrorString));
 
-        testCompiler.tweakHeader([](QV4::CompiledData::Unit *header) {
+        const QString qtVersionFile = QStringLiteral("qtversion.qml");
+        QVERIFY(testCompiler.tweakHeader([](QV4::CompiledData::Unit *header) {
             header->qtVersion = 0;
-        });
+        }, qtVersionFile));
 
-        QVERIFY(!testCompiler.verify());
+        QVERIFY(!testCompiler.verify(qtVersionFile));
         QCOMPARE(testCompiler.lastErrorString, QString::fromUtf8("Qt version mismatch. Found 0 expected %1").arg(QT_VERSION, 0, 16));
-        testCompiler.clearCache();
+        testCompiler.clearCache(qtVersionFile);
     }
 
     {
         testCompiler.clearCache();
         QVERIFY2(testCompiler.compile(contents), qPrintable(testCompiler.lastErrorString));
 
-        testCompiler.tweakHeader([](QV4::CompiledData::Unit *header) {
+        const QString versionFile = QStringLiteral("version.qml");
+        QVERIFY(testCompiler.tweakHeader([](QV4::CompiledData::Unit *header) {
             header->version = 0;
-        });
+        }, versionFile));
 
-        QVERIFY(!testCompiler.verify());
+        QVERIFY(!testCompiler.verify(versionFile));
         QCOMPARE(testCompiler.lastErrorString, QString::fromUtf8("V4 data structure version mismatch. Found 0 expected %1").arg(QV4_DATA_STRUCTURE_VERSION, 0, 16));
+        testCompiler.clearCache(versionFile);
     }
 }
 
@@ -963,6 +1010,26 @@ void tst_qmldiskcache::cacheModuleScripts()
     }
 }
 
+void tst_qmldiskcache::reuseStaticMappings()
+{
+    QQmlEngine engine;
+
+    TestCompiler testCompiler(&engine);
+    QVERIFY(testCompiler.tempDir.isValid());
+
+    QVERIFY2(testCompiler.compile("import QtQml 2.15\nQtObject { objectName: 'foobar' }\n"),
+             qPrintable(testCompiler.lastErrorString));
+
+    const quintptr data1 = testCompiler.unitData();
+    QVERIFY(data1 != 0);
+    QCOMPARE(testCompiler.unitData(), data1);
+
+    testCompiler.reset();
+    QVERIFY(testCompiler.loadTestFile());
+
+    QCOMPARE(testCompiler.unitData(), data1);
+}
+
 QTEST_MAIN(tst_qmldiskcache)
 
 #include "tst_qmldiskcache.moc"
diff --git a/tests/auto/qml/qmltyperegistrar/foreign/foreign.pro b/tests/auto/qml/qmltyperegistrar/foreign/foreign.pro
index 87521eac43..006439b58a 100644
--- a/tests/auto/qml/qmltyperegistrar/foreign/foreign.pro
+++ b/tests/auto/qml/qmltyperegistrar/foreign/foreign.pro
@@ -2,7 +2,6 @@ TEMPLATE = lib
 QT = core
 
 macos:CONFIG -= app_bundle
-CONFIG -= debug_and_release_target
 
 SOURCES = foreign.cpp
 HEADERS = foreign.h
diff --git a/tests/auto/qml/qmltyperegistrar/tst_qmltyperegistrar.pro b/tests/auto/qml/qmltyperegistrar/tst_qmltyperegistrar.pro
index fe21b122c2..3589743f0c 100644
--- a/tests/auto/qml/qmltyperegistrar/tst_qmltyperegistrar.pro
+++ b/tests/auto/qml/qmltyperegistrar/tst_qmltyperegistrar.pro
@@ -17,4 +17,9 @@ QML_IMPORT_NAME = QmlTypeRegistrarTest
 QML_IMPORT_VERSION = 1.0
 
 INCLUDEPATH += foreign
-LIBS += -Lforeign -lforeign
+debug_and_release {
+    CONFIG(release, debug|release): LIBS += -Lforeign/release -lforeign
+    else:  LIBS += -Lforeign/debug -lforeign
+} else {
+    LIBS += -Lforeign -lforeign
+}
diff --git a/tests/auto/qml/qqmlapplicationengine/data/Required.qml b/tests/auto/qml/qqmlapplicationengine/data/Required.qml
new file mode 100644
index 0000000000..acf4a00ce6
--- /dev/null
+++ b/tests/auto/qml/qqmlapplicationengine/data/Required.qml
@@ -0,0 +1,6 @@
+import QtQml 2.15
+
+QtObject
+{
+    required property int foo
+}
diff --git a/tests/auto/qml/qqmlapplicationengine/data/requiredViolation.qml b/tests/auto/qml/qqmlapplicationengine/data/requiredViolation.qml
new file mode 100644
index 0000000000..c5de4661a9
--- /dev/null
+++ b/tests/auto/qml/qqmlapplicationengine/data/requiredViolation.qml
@@ -0,0 +1,3 @@
+import QtQml 2.15
+
+Required {}
diff --git a/tests/auto/qml/qqmlapplicationengine/tst_qqmlapplicationengine.cpp b/tests/auto/qml/qqmlapplicationengine/tst_qqmlapplicationengine.cpp
index f636e527c3..4306c7b8ca 100644
--- a/tests/auto/qml/qqmlapplicationengine/tst_qqmlapplicationengine.cpp
+++ b/tests/auto/qml/qqmlapplicationengine/tst_qqmlapplicationengine.cpp
@@ -56,6 +56,7 @@ private slots:
     void translationChange();
     void setInitialProperties();
     void failureToLoadTriggersWarningSignal();
+    void errorWhileCreating();
 
 private:
     QString buildDir;
@@ -333,6 +334,23 @@ void tst_qqmlapplicationengine::failureToLoadTriggersWarningSignal()
     QTRY_COMPARE(warningObserver.count(), 1);
 }
 
+void tst_qqmlapplicationengine::errorWhileCreating()
+{
+    auto url = testFileUrl("requiredViolation.qml");
+    QQmlApplicationEngine test;
+    QSignalSpy observer(&test, &QQmlApplicationEngine::objectCreated);
+
+    QTest::ignoreMessage(QtMsgType::QtWarningMsg, "QQmlApplicationEngine failed to create component");
+    QTest::ignoreMessage(QtMsgType::QtWarningMsg, qPrintable(QStringLiteral("%1:5:5: Required property foo was not initialized").arg(testFileUrl("Required.qml").toString())));
+
+    test.load(url);
+
+    QTRY_COMPARE(observer.count(), 1);
+    QList<QVariant> args = observer.takeFirst();
+    QVERIFY(args.at(0).isNull());
+    QCOMPARE(args.at(1).toUrl(), url);
+}
+
 QTEST_MAIN(tst_qqmlapplicationengine)
 
 #include "tst_qqmlapplicationengine.moc"
diff --git a/tests/auto/qml/qqmldelegatemodel/data/redrawUponColumnChange.qml b/tests/auto/qml/qqmldelegatemodel/data/redrawUponColumnChange.qml
new file mode 100644
index 0000000000..206133bb39
--- /dev/null
+++ b/tests/auto/qml/qqmldelegatemodel/data/redrawUponColumnChange.qml
@@ -0,0 +1,11 @@
+import QtQuick 2.8
+
+ListView {
+    id: root
+    width: 200
+    height: 200
+
+    delegate: Text {
+        text: display
+    }
+}
diff --git a/tests/auto/qml/qqmldelegatemodel/data/removeFromGroup.qml b/tests/auto/qml/qqmldelegatemodel/data/removeFromGroup.qml
new file mode 100644
index 0000000000..4ae1a8aacc
--- /dev/null
+++ b/tests/auto/qml/qqmldelegatemodel/data/removeFromGroup.qml
@@ -0,0 +1,45 @@
+import QtQuick 2.8
+import QtQml.Models 2.1
+
+Item {
+    id: root
+    width: 200
+    height: 200
+
+    DelegateModel {
+        id: visualModel
+        model: ListModel {
+            id: myLM
+            ListElement {
+                name: "Apple"
+            }
+            ListElement {
+                name: "Banana"
+            }
+            ListElement {
+                name: "Orange"
+            }
+        }
+        filterOnGroup: "selected"
+        groups: [
+            DelegateModelGroup {
+                name: "selected"
+                includeByDefault: true
+            }
+        ]
+        delegate: Text {
+            Component.onCompleted: {
+                if (index === 1) {
+                    DelegateModel.inSelected = false
+                }
+            }
+            text: index + ": " + model.name
+        }
+    }
+
+    // Needs an actual ListView in order for the DelegateModel to instantiate all items
+    ListView {
+        model: visualModel
+        anchors.fill: parent
+    }
+}
diff --git a/tests/auto/qml/qqmldelegatemodel/qqmldelegatemodel.pro b/tests/auto/qml/qqmldelegatemodel/qqmldelegatemodel.pro
index 7fdd3ab5f1..fbd72f6a44 100644
--- a/tests/auto/qml/qqmldelegatemodel/qqmldelegatemodel.pro
+++ b/tests/auto/qml/qqmldelegatemodel/qqmldelegatemodel.pro
@@ -2,7 +2,7 @@ CONFIG += testcase
 TARGET = tst_qqmldelegatemodel
 macos:CONFIG -= app_bundle
 
-QT += qml testlib core-private qml-private qmlmodels-private
+QT += qml quick testlib core-private qml-private qmlmodels-private
 
 SOURCES += tst_qqmldelegatemodel.cpp
 
diff --git a/tests/auto/qml/qqmldelegatemodel/tst_qqmldelegatemodel.cpp b/tests/auto/qml/qqmldelegatemodel/tst_qqmldelegatemodel.cpp
index 87f42c0c8a..4c1eae7ac7 100644
--- a/tests/auto/qml/qqmldelegatemodel/tst_qqmldelegatemodel.cpp
+++ b/tests/auto/qml/qqmldelegatemodel/tst_qqmldelegatemodel.cpp
@@ -27,8 +27,12 @@
 ****************************************************************************/
 
 #include <QtTest/qtest.h>
+#include <QtCore/QConcatenateTablesProxyModel>
+#include <QtGui/QStandardItemModel>
 #include <QtQml/qqmlcomponent.h>
 #include <QtQmlModels/private/qqmldelegatemodel_p.h>
+#include <QtQuick/qquickview.h>
+#include <QtQuick/qquickitem.h>
 
 #include "../../shared/util.h"
 
@@ -42,6 +46,8 @@ public:
 private slots:
     void valueWithoutCallingObjectFirst_data();
     void valueWithoutCallingObjectFirst();
+    void filterOnGroup_removeWhenCompleted();
+    void redrawUponColumnChange();
 };
 
 class AbstractItemModel : public QAbstractItemModel
@@ -134,6 +140,42 @@ void tst_QQmlDelegateModel::valueWithoutCallingObjectFirst()
     QCOMPARE(model->variantValue(index, role), expectedValue);
 }
 
+void tst_QQmlDelegateModel::filterOnGroup_removeWhenCompleted()
+{
+    QQuickView view(testFileUrl("removeFromGroup.qml"));
+    QCOMPARE(view.status(), QQuickView::Ready);
+    view.show();
+    QQuickItem *root = view.rootObject();
+    QVERIFY(root);
+    QQmlDelegateModel *model = root->findChild<QQmlDelegateModel*>();
+    QVERIFY(model);
+    QTest::qWaitFor([=]{ return model->count() == 2; } );
+}
+
+void tst_QQmlDelegateModel::redrawUponColumnChange()
+{
+    QStandardItemModel m1;
+    m1.appendRow({
+            new QStandardItem("Banana"),
+            new QStandardItem("Coconut"),
+    });
+
+    QQuickView view(testFileUrl("redrawUponColumnChange.qml"));
+    QCOMPARE(view.status(), QQuickView::Ready);
+    view.show();
+    QQuickItem *root = view.rootObject();
+    root->setProperty("model", QVariant::fromValue<QObject *>(&m1));
+
+    QObject *item = root->property("currentItem").value<QObject *>();
+    QVERIFY(item);
+    QCOMPARE(item->property("text").toString(), "Banana");
+
+    QVERIFY(root);
+    m1.removeColumn(0);
+
+    QCOMPARE(item->property("text").toString(), "Coconut");
+}
+
 QTEST_MAIN(tst_QQmlDelegateModel)
 
 #include "tst_qqmldelegatemodel.moc"
diff --git a/tests/auto/qml/qqmlecmascript/data/generatorCrashNewProperty.qml b/tests/auto/qml/qqmlecmascript/data/generatorCrashNewProperty.qml
new file mode 100644
index 0000000000..f775b4c613
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/generatorCrashNewProperty.qml
@@ -0,0 +1,20 @@
+// QTBUG-91491
+import QtQml 2.15
+
+QtObject {
+   property int a: 42
+   property int b: 0
+   property int c: 0
+
+   function f(myfunc) {
+      let gen = myfunc();
+      gen["u"] = 0 // Adding members to the generator used to cause crashes when calling next()
+      c = gen.next().value
+   }
+
+   function refreshA() {
+      f(function*() { b = 12; return a });
+   }
+
+   Component.onCompleted: refreshA();
+}
diff --git a/tests/auto/qml/qqmlecmascript/data/proxyIteration.qml b/tests/auto/qml/qqmlecmascript/data/proxyIteration.qml
new file mode 100644
index 0000000000..affba7d9f1
--- /dev/null
+++ b/tests/auto/qml/qqmlecmascript/data/proxyIteration.qml
@@ -0,0 +1,29 @@
+import QtQml 2
+
+QtObject {
+  id: root
+  property int sum
+  Component.onCompleted: {
+    const target = { prop1: 1, prop2: 2, prop3: 3 };
+    const handler = {
+      get: function(target, key) {
+        return target[key]+1;
+      },
+      ownKeys: function() {
+        return ["prop1", "prop3"];
+      },
+      getOwnPropertyDescriptor: function(target, key) {
+        return {
+          value: this.get(target, key),
+          enumerable: true,
+          configurable: true
+        };
+      }
+    };
+    const proxy = new Proxy(target, handler);
+    for (var prop in proxy) {
+      root.sum += proxy[prop] // prop2 gets skipped, the values of 1 and 3 get incremented
+    }
+    // so root.sum should be 6 now
+  }
+}
diff --git a/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp b/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
index 1e10841430..3c3a2a7a99 100644
--- a/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
+++ b/tests/auto/qml/qqmlecmascript/tst_qqmlecmascript.cpp
@@ -239,6 +239,7 @@ private slots:
     void eval();
     void function();
     void topLevelGeneratorFunction();
+    void generatorCrashNewProperty();
     void qtbug_10696();
     void qtbug_11606();
     void qtbug_11600();
@@ -382,7 +383,8 @@ private slots:
     void semicolonAfterProperty();
     void hugeStack();
     void variantConversionMethod();
-
+    void proxyIteration();
+    void proxyHandlerTraps();
     void gcCrashRegressionTest();
 
 private:
@@ -6488,6 +6490,21 @@ void tst_qqmlecmascript::topLevelGeneratorFunction()
     QCOMPARE(it.property("next").callWithInstance(it).property("value").toInt(), 1);
 }
 
+// QTBUG-91491
+void tst_qqmlecmascript::generatorCrashNewProperty()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine, testFileUrl("generatorCrashNewProperty.qml"));
+
+    QScopedPointer<QObject> o(component.create());
+
+    QVERIFY2(o != nullptr, qPrintable(component.errorString()));
+
+    QCOMPARE(o->property("a").toInt(), 42);
+    QCOMPARE(o->property("b").toInt(), 12);
+    QCOMPARE(o->property("c").toInt(), 42);
+}
+
 // Test the "Qt.include" method
 void tst_qqmlecmascript::include()
 {
@@ -9306,6 +9323,44 @@ void tst_qqmlecmascript::variantConversionMethod()
     QCOMPARE(obj.funcCalled, QLatin1String("QModelIndex"));
 }
 
+void tst_qqmlecmascript::proxyIteration()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine, testFileUrl("proxyIteration.qml"));
+    QScopedPointer<QObject> root(component.create());
+    QVERIFY2(root != nullptr, qPrintable(component.errorString()));
+    QCOMPARE(root->property("sum").toInt(), 6);
+}
+
+void tst_qqmlecmascript::proxyHandlerTraps()
+{
+    const QString expression = QStringLiteral(R"SNIPPET(
+        (function(){
+            const target = {
+                prop: 47
+            };
+            const handler = {
+                getOwnPropertyDescriptor(target, prop) {
+                    return { configurable: true, enumerable: true, value: 47 };
+                }
+            };
+            const proxy = new Proxy(target, handler);
+
+            // QTBUG-88786
+            if (!proxy.propertyIsEnumerable("prop"))
+                throw Error("FAIL: propertyisEnumerable");
+            if (!proxy.hasOwnProperty("prop"))
+                throw Error("FAIL: hasOwnProperty");
+
+            return "SUCCESS";
+        })()
+    )SNIPPET");
+
+    QJSEngine engine;
+    QJSValue value = engine.evaluate(expression);
+    QVERIFY(value.isString() && value.toString() == QStringLiteral("SUCCESS"));
+}
+
 QTEST_MAIN(tst_qqmlecmascript)
 
 #include "tst_qqmlecmascript.moc"
diff --git a/tests/auto/qml/qqmlincubator/tst_qqmlincubator.cpp b/tests/auto/qml/qqmlincubator/tst_qqmlincubator.cpp
index 549aae8c2b..25adf4f31d 100644
--- a/tests/auto/qml/qqmlincubator/tst_qqmlincubator.cpp
+++ b/tests/auto/qml/qqmlincubator/tst_qqmlincubator.cpp
@@ -71,6 +71,7 @@ private slots:
     void contextDelete();
     void garbageCollection();
     void requiredProperties();
+    void deleteInSetInitialState();
 
 private:
     QQmlIncubationController controller;
@@ -1213,6 +1214,38 @@ void tst_qqmlincubator::requiredProperties()
     }
 }
 
+class DeletingIncubator : public QQmlIncubator
+{
+
+
+    // QQmlIncubator interface
+protected:
+    void statusChanged(Status) override
+    {
+
+    }
+    void setInitialState(QObject *obj) override
+    {
+        delete obj;
+        clear();
+    }
+};
+
+void tst_qqmlincubator::deleteInSetInitialState()
+{
+    QQmlComponent component(&engine, testFileUrl("requiredProperty.qml"));
+    QVERIFY(component.isReady());
+    // forceCompletion immediately after creating an asynchronous object completes it
+    DeletingIncubator incubator;
+    incubator.setInitialProperties({{"requiredProperty", 42}});
+    QVERIFY(incubator.isNull());
+    component.create(incubator);
+    QVERIFY(incubator.isLoading());
+    incubator.forceCompletion(); // no crash
+    QVERIFY(incubator.isNull());
+    QCOMPARE(incubator.object(), nullptr); // object was deleted
+}
+
 QTEST_MAIN(tst_qqmlincubator)
 
 #include "tst_qqmlincubator.moc"
diff --git a/tests/auto/qml/qqmllanguage/data/Tab1.qml b/tests/auto/qml/qqmllanguage/data/Tab1.qml
new file mode 100644
index 0000000000..e1cd6d8c34
--- /dev/null
+++ b/tests/auto/qml/qqmllanguage/data/Tab1.qml
@@ -0,0 +1,9 @@
+import QtQuick 2.15
+
+Item {
+    component LeftTab: Item {
+    }
+
+    component RightTab: Item {
+    }
+}
diff --git a/tests/auto/qml/qqmllanguage/data/bareInline.qml b/tests/auto/qml/qqmllanguage/data/bareInline.qml
new file mode 100644
index 0000000000..cb79021250
--- /dev/null
+++ b/tests/auto/qml/qqmllanguage/data/bareInline.qml
@@ -0,0 +1,9 @@
+import QtQuick 2.9
+
+Item {
+    width: 800
+    height: 600
+    visible: true
+
+    Tab1.RightTab {}
+}
diff --git a/tests/auto/qml/qqmllanguage/data/inlineComponentsSameFile.qml b/tests/auto/qml/qqmllanguage/data/inlineComponentsSameFile.qml
new file mode 100644
index 0000000000..87cac10200
--- /dev/null
+++ b/tests/auto/qml/qqmllanguage/data/inlineComponentsSameFile.qml
@@ -0,0 +1,11 @@
+import QtQml 2.15
+
+QtObject {
+    component IC : QtObject {
+        property string name
+        property int age
+    }
+
+    property IC other: IC { name: "Toby"; age: 30 }
+    property list<IC> listProp: [IC { name: "Alfred Ill"; age: 65 }, IC { name: "Claire Zachanassian"; age: 62}]
+}
diff --git a/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp b/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
index 8adcbc1837..de8b2ef7eb 100644
--- a/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
+++ b/tests/auto/qml/qqmllanguage/tst_qqmllanguage.cpp
@@ -48,6 +48,7 @@
 #include <private/qqmlscriptstring_p.h>
 #include <private/qqmlvmemetaobject_p.h>
 #include <private/qqmlcomponent_p.h>
+#include <private/qqmltype_p_p.h>
 
 #include "testtypes.h"
 #include "testhttpserver.h"
@@ -331,6 +332,7 @@ private slots:
     void arrayToContainer();
     void qualifiedScopeInCustomParser();
     void accessNullPointerPropertyCache();
+    void bareInlineComponent();
 
 private:
     QQmlEngine engine;
@@ -5604,6 +5606,7 @@ void tst_qqmllanguage::inlineComponent_data()
     QTest::newRow("Alias resolves correctly") << testFileUrl("inlineComponentWithAlias.qml") << QColorConstants::Svg::lime << 42 << true;
 
     QTest::newRow("Two inline components in same do not crash (QTBUG-86989)") << testFileUrl("twoInlineComponents.qml") << QColor() << 0 << false;
+    QTest::newRow("Inline components used in same file (QTBUG-89173)") << testFileUrl("inlineComponentsSameFile.qml") << QColor() << 0 << false;
 }
 
 void tst_qqmllanguage::inlineComponentReferenceCycle_data()
@@ -5812,6 +5815,32 @@ void tst_qqmllanguage::accessNullPointerPropertyCache()
     QVERIFY(!obj.isNull());
 }
 
+void tst_qqmllanguage::bareInlineComponent()
+{
+    QQmlEngine engine;
+
+    QQmlComponent c(&engine, testFileUrl("bareInline.qml"));
+    QVERIFY2(c.isReady(), qPrintable(c.errorString()));
+    QScopedPointer<QObject> o(c.create());
+    QVERIFY(!o.isNull());
+
+    QQmlMetaType::freeUnusedTypesAndCaches();
+
+    bool tab1Found = false;
+    const auto types = QQmlMetaType::qmlTypes();
+    for (const QQmlType &type : types) {
+        if (type.elementName() == QStringLiteral("Tab1")) {
+            QVERIFY(type.module().isEmpty());
+            tab1Found = true;
+            const auto ics = type.priv()->objectIdToICType;
+            QVERIFY(ics.size() > 0);
+            for (const QQmlType &ic : ics)
+                QVERIFY(ic.containingType() == type);
+        }
+    }
+    QVERIFY(tab1Found);
+}
+
 QTEST_MAIN(tst_qqmllanguage)
 
 #include "tst_qqmllanguage.moc"
diff --git a/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp b/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
index d54e3467b7..1953798a15 100644
--- a/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
+++ b/tests/auto/qml/qqmllistmodel/tst_qqmllistmodel.cpp
@@ -130,6 +130,7 @@ private slots:
     void dynamic_roles_crash_QTBUG_38907();
     void nestedListModelIteration();
     void undefinedAppendShouldCauseError();
+    void nullPropertyCrash();
 };
 
 bool tst_qqmllistmodel::compareVariantList(const QVariantList &testList, QVariant object)
@@ -1723,6 +1724,27 @@ void tst_qqmllistmodel::undefinedAppendShouldCauseError()
     QScopedPointer<QObject>(component.create());
 }
 
+// QTBUG-89173
+void tst_qqmllistmodel::nullPropertyCrash()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine);
+    component.setData(
+            R"(import QtQuick 2.15
+            ListView {
+                model: ListModel { id: listModel }
+
+                delegate: Item {}
+
+                Component.onCompleted: {
+                    listModel.append({"a": "value1", "b":[{"c":"value2"}]})
+                    listModel.append({"a": "value2", "b":[{"c":null}]})
+                }
+            })",
+            QUrl());
+    QTest::ignoreMessage(QtMsgType::QtWarningMsg, "<Unknown File>: c is null. Adding an object with a null member does not create a role for it.");
+    QScopedPointer<QObject>(component.create());
+}
 
 QTEST_MAIN(tst_qqmllistmodel)
 
diff --git a/tests/auto/qml/qqmllistmodelworkerscript/data/listmodel_async_sort/ListModelSort.mjs b/tests/auto/qml/qqmllistmodelworkerscript/data/listmodel_async_sort/ListModelSort.mjs
new file mode 100644
index 0000000000..cfc1e1146f
--- /dev/null
+++ b/tests/auto/qml/qqmllistmodelworkerscript/data/listmodel_async_sort/ListModelSort.mjs
@@ -0,0 +1,117 @@
+/* Copyright 2020 Esri
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+//------------------------------------------------------------------------------
+
+export const OrderAscending = 0
+export const OrderDescending = 1
+
+//------------------------------------------------------------------------------
+
+export function sort(model, sortKey, descending, useMove) {
+
+    _sort(model, sortKey, descending, useMove);
+}
+
+//------------------------------------------------------------------------------
+
+function _sort(model, sortKey, descending, useMove) {
+    var lessThan =  descending ? 1 : -1;
+    var greaterThan = -lessThan;
+
+    var indices = [...new Array(model.count).keys()];
+
+    function getKeyValue(index) {
+        return model.get(index)[sortKey];
+    }
+
+    function compareKey(index1, index2) {
+        var value1 = getKeyValue(index1);
+        var value2 = getKeyValue(index2);
+
+        return (value1 < value2)
+                ? lessThan
+                : (value1 > value2)
+                  ? greaterThan
+                  : 0;
+    }
+
+    indices.sort(compareKey);
+
+
+    function compareFrom(i1, i2) {
+        return (i1.from < i2.from)
+                ? -1
+                : (i1.from > i2.from)
+                  ? 1
+                  : 0;
+    }
+
+    var swapIndices = indices.map((e, i) => { return { from: e, to: i }}).sort(compareFrom).map(e => e.to);
+
+    function clone(o) {
+        return JSON.parse(JSON.stringify(o));
+    }
+
+    function cloneSwap(a, b) {
+        var o = clone(model.get(a));
+        model.set(a, model.get(b));
+        model.set(b, o);
+    }
+
+    function moveSwap(a, b) {
+        if (a < b) {
+            model.move(a, b, 1);
+            model.move(b - 1, a, 1);
+        }
+        else if (a > b) {
+            model.move(b, a, 1);
+            model.move(a - 1, b, 1);
+        }
+    }
+
+
+    var swap = useMove ? moveSwap : cloneSwap;
+    var swapCount = 0;
+
+
+    for (var iFrom = 0; iFrom < swapIndices.length; iFrom++) {
+        var iTo = swapIndices[iFrom];
+
+        if (iFrom === iTo) {
+            continue;
+        }
+
+        do {
+            swap(iFrom, iTo);
+
+            var t = swapIndices[iFrom];
+            swapIndices[iFrom] = swapIndices[iTo]
+            swapIndices[iTo] = t;
+
+            iTo = swapIndices[iFrom];
+
+            swapCount++;
+        }
+        while (iFrom !== iTo);
+    }
+
+}
+
+//------------------------------------------------------------------------------
+
+
+
diff --git a/tests/auto/qml/qqmllistmodelworkerscript/data/listmodel_async_sort/ListModelSort.qml b/tests/auto/qml/qqmllistmodelworkerscript/data/listmodel_async_sort/ListModelSort.qml
new file mode 100644
index 0000000000..2679925c80
--- /dev/null
+++ b/tests/auto/qml/qqmllistmodelworkerscript/data/listmodel_async_sort/ListModelSort.qml
@@ -0,0 +1,166 @@
+/* Copyright 2020 Esri
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+import QtQml 2.13
+import QtQml.Models 2.13
+
+import QtQuick 2.13
+import QtQuick.Layouts 1.12
+
+import "ListModelSort.mjs" as ListModelSort
+
+Item {
+    Component.onCompleted: {
+        fillModel(namesModel, "A, D, E, B, C, A");
+    }
+
+
+    function verify() {
+        let expected = ["A", "A", "B", "C", "D", "E"]
+        let sorted = listView.count === 6
+        for (let i = 0; i<listView.count;++i) {
+            sorted = sorted && (listView.itemAtIndex(i).name === expected[i])
+        }
+        return sorted
+    }
+
+    function doSort() {
+        sortAsync(namesModel, "name", false, false)
+    }
+
+
+    function random(n) {
+        return Math.round(Math.random(new Date().valueOf()) * n);
+    }
+
+    function fillModel(model, values) {
+        var names = values.split(",").map(name => name.trim()).filter(name => name > "");
+
+
+        model.clear();
+
+        for (const name of names) {
+            model.append({
+                             name: name,
+                             number: random(names.length)
+                         });
+        }
+    }
+
+    //--------------------------------------------------------------------------
+
+    ListModel {
+        id: namesModel
+
+        objectName: "namesModel"
+    }
+
+    //--------------------------------------------------------------------------
+    ColumnLayout {
+        anchors {
+            fill: parent
+            margins: 10
+        }
+
+        ListView {
+            id: listView
+
+            Layout.fillWidth: true
+            Layout.fillHeight: true
+
+            model: namesModel
+            clip: true
+            spacing: 5
+
+            delegate: Text {
+                required property string name
+                required property int number
+                width: ListView.view.width
+                text: "%1 (%2)".arg(name).arg(number)
+                horizontalAlignment: Text.AlignHCenter
+                wrapMode: Text.WrapAtWordBoundaryOrAnywhere
+            }
+
+            add: Transition {
+                NumberAnimation { property: "opacity"; from: 0; to: 1.0; duration: 400 }
+                NumberAnimation { property: "scale"; from: 0; to: 1.0; duration: 400 }
+            }
+
+            addDisplaced: Transition {
+                NumberAnimation { properties: "x,y"; duration: 100 }
+            }
+
+            move: Transition {
+                NumberAnimation { properties: "x,y"; duration: 100 }
+            }
+
+            moveDisplaced: Transition {
+                NumberAnimation { properties: "x,y"; duration: 100 }
+            }
+
+            displaced: Transition {
+                NumberAnimation { properties: "x,y"; duration: 40; easing.type: Easing.OutBounce }
+            }
+
+            populate: Transition {
+                NumberAnimation { properties: "x,y"; duration: 100 }
+            }
+
+            remove: Transition {
+                ParallelAnimation {
+                    NumberAnimation { property: "opacity"; to: 0; duration: 100 }
+                    NumberAnimation { properties: "x,y"; to: 100; duration: 100 }
+                }
+            }
+
+            removeDisplaced: Transition {
+                NumberAnimation { properties: "x,y"; duration: 100 }
+            }
+        }
+        }
+
+
+    function sortSync(model, sortKey, descending, useMove) {
+
+        ListModelSort.sort(model, sortKey, descending, useMove);
+    }
+
+    //--------------------------------------------------------------------------
+
+    function sortAsync(model, sortKey, descending, useMove) {
+
+        var params = {
+            debug: true,
+            model: model,
+            sortKey: sortKey,
+            descending: descending,
+            useMove: useMove
+        };
+
+
+        sortWorker.sendMessage(params);
+    }
+
+    WorkerScript {
+        id: sortWorker
+
+        source: "ListModelSortWorker.mjs"
+    }
+
+    //--------------------------------------------------------------------------
+
+}
+
diff --git a/tests/auto/qml/qqmllistmodelworkerscript/data/listmodel_async_sort/ListModelSortWorker.mjs b/tests/auto/qml/qqmllistmodelworkerscript/data/listmodel_async_sort/ListModelSortWorker.mjs
new file mode 100644
index 0000000000..fa3b5c27ec
--- /dev/null
+++ b/tests/auto/qml/qqmllistmodelworkerscript/data/listmodel_async_sort/ListModelSortWorker.mjs
@@ -0,0 +1,38 @@
+/* Copyright 2020 Esri
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+import * as ListModelSort from "ListModelSort.mjs";
+
+//------------------------------------------------------------------------------
+
+WorkerScript.onMessage = function(params) {
+
+    params.model.sync();
+
+    const debug = params.debug;
+
+    ListModelSort.sort(params.model, params.sortKey, !!params.descending, !!params.useMove);
+
+    params.model.sync();
+
+
+    WorkerScript.sendMessage({
+                                 text: "Sorted"
+                             });
+}
+
+//------------------------------------------------------------------------------
+
diff --git a/tests/auto/qml/qqmllistmodelworkerscript/data/listmodel_async_sort/main.qml b/tests/auto/qml/qqmllistmodelworkerscript/data/listmodel_async_sort/main.qml
new file mode 100644
index 0000000000..88a23511fa
--- /dev/null
+++ b/tests/auto/qml/qqmllistmodelworkerscript/data/listmodel_async_sort/main.qml
@@ -0,0 +1,23 @@
+import QtQuick 2.13
+import QtQuick.Window 2.13
+
+Window {
+    visible: true
+    width: 640
+    height: 640
+    title: qsTr("Hello World")
+
+    ListModelSort {
+        id: lms
+        anchors.fill: parent
+    }
+
+    function doSort() {
+        lms.doSort()
+    }
+
+    function verify(): bool {
+        let ok = lms.verify()
+        return ok
+    }
+}
diff --git a/tests/auto/qml/qqmllistmodelworkerscript/tst_qqmllistmodelworkerscript.cpp b/tests/auto/qml/qqmllistmodelworkerscript/tst_qqmllistmodelworkerscript.cpp
index b5e8800d0e..edcfc4994d 100644
--- a/tests/auto/qml/qqmllistmodelworkerscript/tst_qqmllistmodelworkerscript.cpp
+++ b/tests/auto/qml/qqmllistmodelworkerscript/tst_qqmllistmodelworkerscript.cpp
@@ -104,6 +104,7 @@ private slots:
     void worker_remove_list();
     void dynamic_role_data();
     void dynamic_role();
+    void correctMoves();
 };
 
 bool tst_qqmllistmodelworkerscript::compareVariantList(const QVariantList &testList, QVariant object)
@@ -842,6 +843,22 @@ void tst_qqmllistmodelworkerscript::dynamic_role()
     qApp->processEvents();
 }
 
+void tst_qqmllistmodelworkerscript::correctMoves()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine, testFileUrl("listmodel_async_sort/main.qml"));
+    QScopedPointer<QObject> root {component.create()};
+    QVERIFY2(root, qPrintable(component.errorString()));
+    bool ok =QMetaObject::invokeMethod(root.get(), "doSort");
+    QVERIFY(ok);
+    auto check = [&](){
+        bool success = false;
+        QMetaObject::invokeMethod(root.get(), "verify", Q_RETURN_ARG(bool, success));
+        return success;
+    };
+    QTRY_VERIFY(check());
+}
+
 QTEST_MAIN(tst_qqmllistmodelworkerscript)
 
 #include "tst_qqmllistmodelworkerscript.moc"
diff --git a/tests/auto/qml/qqmllocale/tst_qqmllocale.cpp b/tests/auto/qml/qqmllocale/tst_qqmllocale.cpp
index 7d0c10a702..822fe33b83 100644
--- a/tests/auto/qml/qqmllocale/tst_qqmllocale.cpp
+++ b/tests/auto/qml/qqmllocale/tst_qqmllocale.cpp
@@ -73,7 +73,7 @@ private slots:
     void dateTimeFormat();
     void timeFormat_data();
     void timeFormat();
-#if defined(Q_OS_UNIX)
+#if defined(Q_OS_UNIX) && QT_CONFIG(timezone)
     void timeZoneUpdated();
 #endif
 
@@ -1276,7 +1276,7 @@ QString DateFormatter::getLocalizedForm(const QString &isoTimestamp)
     return locale.toString(input);
 }
 
-#if defined(Q_OS_UNIX)
+#if defined(Q_OS_UNIX) && QT_CONFIG(timezone)
 // Currently disabled on Windows as adjusting the timezone
 // requires additional privileges that aren't normally
 // enabled for a process. This can be achieved by calling
@@ -1327,8 +1327,10 @@ void tst_qqmllocale::timeZoneUpdated()
     obj.reset(c.create());
     QVERIFY(obj);
 
-#if !defined(Q_OS_WIN) && QT_CONFIG(timezone) && (!defined(Q_OS_LINUX) || defined(Q_OS_ANDROID))
-    QEXPECT_FAIL("", "Date.timeZoneUpdated() only works on non-Android Linux with QT_CONFIG(timezone).", Continue);
+#if !defined(Q_OS_LINUX) || defined(Q_OS_ANDROID)
+    QEXPECT_FAIL("",
+                 "Date.timeZoneUpdated() only works on non-Android Linux with QT_CONFIG(timezone).",
+                 Continue);
 #endif
     QVERIFY(obj->property("success").toBool());
 
@@ -1337,12 +1339,14 @@ void tst_qqmllocale::timeZoneUpdated()
 
     QMetaObject::invokeMethod(obj.data(), "check");
 
-#if !defined(Q_OS_WIN) && QT_CONFIG(timezone) && (!defined(Q_OS_LINUX) || defined(Q_OS_ANDROID))
-    QEXPECT_FAIL("", "Date.timeZoneUpdated() only works on non-Android Linux with QT_CONFIG(timezone).", Continue);
+#if !defined(Q_OS_LINUX) || defined(Q_OS_ANDROID)
+    QEXPECT_FAIL("",
+                 "Date.timeZoneUpdated() only works on non-Android Linux with QT_CONFIG(timezone).",
+                 Continue);
 #endif
     QVERIFY(obj->property("success").toBool());
 }
-#endif
+#endif // Unix && timezone
 
 QTEST_MAIN(tst_qqmllocale)
 
diff --git a/tests/auto/qml/qqmlproperty/tst_qqmlproperty.cpp b/tests/auto/qml/qqmlproperty/tst_qqmlproperty.cpp
index 8a96fc52c5..5363cc8fcb 100644
--- a/tests/auto/qml/qqmlproperty/tst_qqmlproperty.cpp
+++ b/tests/auto/qml/qqmlproperty/tst_qqmlproperty.cpp
@@ -164,6 +164,8 @@ private slots:
     void nestedQQmlPropertyMap();
 
     void underscorePropertyChangeHandler();
+
+    void signalExpressionWithoutObject();
 private:
     QQmlEngine engine;
 };
@@ -2210,6 +2212,14 @@ void tst_qqmlproperty::underscorePropertyChangeHandler()
     QVERIFY(changeHandler.isSignalProperty());
 }
 
+void tst_qqmlproperty::signalExpressionWithoutObject()
+{
+    QQmlProperty invalid;
+    QQmlPropertyPrivate::setSignalExpression(invalid, nullptr);
+    QQmlBoundSignalExpression *expr = QQmlPropertyPrivate::signalExpression(invalid);
+    QVERIFY(!expr);
+}
+
 QTEST_MAIN(tst_qqmlproperty)
 
 #include "tst_qqmlproperty.moc"
diff --git a/tests/auto/qml/qv4mm/tst_qv4mm.cpp b/tests/auto/qml/qv4mm/tst_qv4mm.cpp
index 5d635aa63b..824fd89e5b 100644
--- a/tests/auto/qml/qv4mm/tst_qv4mm.cpp
+++ b/tests/auto/qml/qv4mm/tst_qv4mm.cpp
@@ -76,10 +76,10 @@ void tst_qv4mm::multiWrappedQObjects()
         QCOMPARE(engine1.memoryManager->m_pendingFreedObjectWrapperValue.size(), 1);
         QCOMPARE(engine2.memoryManager->m_pendingFreedObjectWrapperValue.size(), 0);
 
-        // Moves the additional WeakValue from m_multiplyWrappedQObjects to
-        // m_pendingFreedObjectWrapperValue. It's still alive after all.
+        // The additional WeakValue from m_multiplyWrappedQObjects hasn't been moved
+        // to m_pendingFreedObjectWrapperValue yet. It's still alive after all.
         engine1.memoryManager->runGC();
-        QCOMPARE(engine1.memoryManager->m_pendingFreedObjectWrapperValue.size(), 2);
+        QCOMPARE(engine1.memoryManager->m_pendingFreedObjectWrapperValue.size(), 1);
 
         // engine2 doesn't own the object as engine1 was the first to wrap it above.
         // Therefore, no effect here.
diff --git a/tests/auto/quick/qquickitem2/data/activeFocusOnTab_infiniteLoop3.qml b/tests/auto/quick/qquickitem2/data/activeFocusOnTab_infiniteLoop3.qml
new file mode 100644
index 0000000000..889e480f3b
--- /dev/null
+++ b/tests/auto/quick/qquickitem2/data/activeFocusOnTab_infiniteLoop3.qml
@@ -0,0 +1,13 @@
+import QtQuick 2.6
+
+Item {
+    visible: true
+    Item {
+        visible: false
+        Item {
+            objectName: "hiddenChild"
+            activeFocusOnTab: true
+            focus: true
+        }
+    }
+}
diff --git a/tests/auto/quick/qquickitem2/tst_qquickitem.cpp b/tests/auto/quick/qquickitem2/tst_qquickitem.cpp
index f65650cf9c..eeff768bb4 100644
--- a/tests/auto/quick/qquickitem2/tst_qquickitem.cpp
+++ b/tests/auto/quick/qquickitem2/tst_qquickitem.cpp
@@ -66,6 +66,7 @@ private slots:
     void activeFocusOnTab10();
     void activeFocusOnTab_infiniteLoop_data();
     void activeFocusOnTab_infiniteLoop();
+    void activeFocusOnTab_infiniteLoopControls();
 
     void nextItemInFocusChain();
     void nextItemInFocusChain2();
@@ -1055,6 +1056,17 @@ void tst_QQuickItem::activeFocusOnTab_infiniteLoop()
     QCOMPARE(item, window->rootObject());
 }
 
+
+void tst_QQuickItem::activeFocusOnTab_infiniteLoopControls()
+{
+    auto source = testFileUrl("activeFocusOnTab_infiniteLoop3.qml");
+    QScopedPointer<QQuickView>window(new QQuickView());
+    window->setSource(source);
+    window->show();
+    QVERIFY(window->errors().isEmpty());
+    QTest::keyClick(window.get(), Qt::Key_Tab); // should not hang
+}
+
 void tst_QQuickItem::nextItemInFocusChain()
 {
     if (!qt_tab_all_widgets())
diff --git a/tests/auto/quick/qquicklayouts/data/tst_rowlayout.qml b/tests/auto/quick/qquicklayouts/data/tst_rowlayout.qml
index 85fe54eca6..87e0a01df2 100644
--- a/tests/auto/quick/qquicklayouts/data/tst_rowlayout.qml
+++ b/tests/auto/quick/qquicklayouts/data/tst_rowlayout.qml
@@ -1233,5 +1233,42 @@ Item {
 
             // DO NOT CRASH due to stack overflow (or loop endlessly due to updatePolish()/polish() loop)
         }
+
+        Component {
+            id: layout_dependentWidth_QTBUG_87253_Component
+
+            RowLayout {
+                anchors.fill: parent;
+
+                RowLayout {
+                    spacing: 10
+
+                    Text {
+                        id: btnOPE
+                        text: qsTr("Ok")
+                        Layout.fillWidth: true
+                        Layout.preferredWidth: (parent.width - 20) / 2
+                    }
+
+                    Text {
+                        id: btnSeeChanged
+                        text: qsTr("Not Ok");
+                        Layout.fillWidth: true
+                        Layout.preferredWidth: (parent.width - 20) / 2
+                    }
+                }
+            }
+        }
+
+        function test_dependentWidth_QTBUG_87253()
+        {
+            var warningMsg = new RegExp("Qt Quick Layouts: Detected recursive rearrange. "
+                                      + "Aborting after two iterations.")
+            for (var i = 0; i < 10; ++i) {
+                ignoreWarning(warningMsg)
+            }
+            var layout = createTemporaryObject(layout_dependentWidth_QTBUG_87253_Component, container)
+            waitForRendering(layout)
+        }
     }
 }
diff --git a/tests/auto/quick/qquicklistview/data/AnimatedButton.qml b/tests/auto/quick/qquicklistview/data/AnimatedButton.qml
new file mode 100644
index 0000000000..19cd580cf5
--- /dev/null
+++ b/tests/auto/quick/qquicklistview/data/AnimatedButton.qml
@@ -0,0 +1,10 @@
+import QtQuick 2.12
+
+/*
+  \qmltype AnimatedButton
+*/
+Rectangle {
+    width: 100
+    height: 20
+    Behavior on color { ColorAnimation { duration : 300 } }
+}
diff --git a/tests/auto/quick/qquicklistview/data/animatedDelegate.qml b/tests/auto/quick/qquicklistview/data/animatedDelegate.qml
new file mode 100644
index 0000000000..46913d87d7
--- /dev/null
+++ b/tests/auto/quick/qquicklistview/data/animatedDelegate.qml
@@ -0,0 +1,35 @@
+import QtQuick 2.12
+
+Item {
+    width: 640
+    height: 480
+
+    property var moreModel: [myDataModelContainer.createObject(null)]
+    property Component myDataModelContainer: Component {
+        QtObject {}
+    }
+
+    function refreshModel() {
+        //copy contents of moreModel
+        var list = moreModel.slice()
+
+        moreModel = [myDataModelContainer.createObject(null), myDataModelContainer.createObject(null)]
+
+        for (var i = 0; i < list.length; i++) {
+            //console.log("trying to destroy ="+list[i])
+            list[i].destroy()
+        }
+    }
+
+    ListView {
+        id: listView
+        objectName: "listView"
+        anchors.fill: parent
+        model: moreModel
+        focus: true
+
+        delegate: AnimatedButton {
+            color: ListView.isCurrentItem ? "red" : "black"
+        }
+    }
+}
diff --git a/tests/auto/quick/qquicklistview/tst_qquicklistview.cpp b/tests/auto/quick/qquicklistview/tst_qquicklistview.cpp
index 2af6b084fb..a7aefbe432 100644
--- a/tests/auto/quick/qquicklistview/tst_qquicklistview.cpp
+++ b/tests/auto/quick/qquicklistview/tst_qquicklistview.cpp
@@ -298,6 +298,7 @@ private slots:
 
     void requiredObjectListModel();
     void clickHeaderAndFooterWhenClip();
+    void animatedDelegate();
 
 private:
     template <class T> void items(const QUrl &source);
@@ -10094,6 +10095,20 @@ void tst_QQuickListView::clickHeaderAndFooterWhenClip() // QTBUG-85302
     QVERIFY(root->property("footerPressed").toBool());
 }
 
+void tst_QQuickListView::animatedDelegate()
+{
+    // QTBUG-86567: Should not crash
+    QScopedPointer<QQuickView> window(createView());
+    window->setSource(testFileUrl("animatedDelegate.qml"));
+    window->show();
+    QVERIFY(QTest::qWaitForWindowExposed(window.data()));
+
+    for (int i = 0; i < 100; ++i) {
+        QMetaObject::invokeMethod(window->rootObject(), "refreshModel");
+        QTest::qWait(10);
+    }
+}
+
 QTEST_MAIN(tst_QQuickListView)
 
 #include "tst_qquicklistview.moc"
diff --git a/tests/auto/quick/qquickloader/data/initialPropertyValues.12.qml b/tests/auto/quick/qquickloader/data/initialPropertyValues.12.qml
new file mode 100644
index 0000000000..940730b307
--- /dev/null
+++ b/tests/auto/quick/qquickloader/data/initialPropertyValues.12.qml
@@ -0,0 +1,20 @@
+import QtQuick 2.0
+
+Item {
+    id: root
+    property int i: 0
+
+    Loader {
+        id: loader
+        objectName: "loader"
+        active: false
+    }
+
+    Component.onCompleted: {
+        loader.setSource("CacheClearTest.qml", {i: 12})
+        loader.active = true
+        loader.active = false
+        loader.active = true
+        root.i = loader.item.i // should be 12
+    }
+}
diff --git a/tests/auto/quick/qquickloader/data/loader-async-race-rect.qml b/tests/auto/quick/qquickloader/data/loader-async-race-rect.qml
new file mode 100644
index 0000000000..a56dcea5ad
--- /dev/null
+++ b/tests/auto/quick/qquickloader/data/loader-async-race-rect.qml
@@ -0,0 +1,10 @@
+import QtQuick 2.15
+
+Rectangle {
+    anchors.fill: parent
+    color: "blue"
+    Item {
+        Item {
+        }
+    }
+}
diff --git a/tests/auto/quick/qquickloader/data/loader-async-race.qml b/tests/auto/quick/qquickloader/data/loader-async-race.qml
new file mode 100644
index 0000000000..8ba625c5c1
--- /dev/null
+++ b/tests/auto/quick/qquickloader/data/loader-async-race.qml
@@ -0,0 +1,14 @@
+import QtQuick 2.15
+
+Item {
+    id: root
+    Component.onCompleted: {
+        myloader.active = false
+    }
+    Loader {
+        id: myloader
+        anchors.fill: parent
+        asynchronous: true
+        source: "loader-async-race-rect.qml"
+    }
+}
diff --git a/tests/auto/quick/qquickloader/tst_qquickloader.cpp b/tests/auto/quick/qquickloader/tst_qquickloader.cpp
index f4b682f3f4..dddacbaa0b 100644
--- a/tests/auto/quick/qquickloader/tst_qquickloader.cpp
+++ b/tests/auto/quick/qquickloader/tst_qquickloader.cpp
@@ -132,6 +132,7 @@ private slots:
     void statusChangeOnlyEmittedOnce();
 
     void setSourceAndCheckStatus();
+    void asyncLoaderRace();
 };
 
 Q_DECLARE_METATYPE(QList<QQmlError>)
@@ -700,6 +701,11 @@ void tst_QQuickLoader::initialPropertyValues_data()
                                                                                     << QStringList()
                                                                                     << (QStringList() << "oldi" << "i")
                                                                                     << (QVariantList() << 12 << 42);
+
+    QTest::newRow("ensure initial properties aren't disposed after active = true") << testFileUrl("initialPropertyValues.12.qml")
+            << QStringList()
+            << (QStringList() << "i")
+            << (QVariantList() << 12);
 }
 
 void tst_QQuickLoader::initialPropertyValues()
@@ -1491,6 +1497,24 @@ void tst_QQuickLoader::setSourceAndCheckStatus()
     QCOMPARE(loader->status(), QQuickLoader::Null);
 }
 
+void tst_QQuickLoader::asyncLoaderRace()
+{
+    QQmlApplicationEngine engine;
+    auto url = testFileUrl("loader-async-race.qml");
+    engine.load(url);
+    auto root = engine.rootObjects().at(0);
+    QVERIFY(root);
+
+    QQuickLoader *loader = root->findChild<QQuickLoader *>();
+    QCOMPARE(loader->active(), false);
+    QCOMPARE(loader->status(), QQuickLoader::Null);
+    QCOMPARE(loader->item(), nullptr);
+
+    QSignalSpy spy(loader, &QQuickLoader::itemChanged);
+    QVERIFY(!spy.wait(100));
+    QCOMPARE(loader->item(), nullptr);
+}
+
 QTEST_MAIN(tst_QQuickLoader)
 
 #include "tst_qquickloader.moc"
diff --git a/tests/auto/quick/qquickmousearea/data/containsMouse.qml b/tests/auto/quick/qquickmousearea/data/containsMouse.qml
new file mode 100644
index 0000000000..c4f1299e49
--- /dev/null
+++ b/tests/auto/quick/qquickmousearea/data/containsMouse.qml
@@ -0,0 +1,14 @@
+import QtQuick 2.15
+
+Rectangle {
+    width: 200
+    height: 200
+    visible: true
+    MouseArea {
+        id: mouseArea
+        objectName: "mouseArea"
+        anchors.fill: parent
+        hoverEnabled: true
+        visible: false
+    }
+}
diff --git a/tests/auto/quick/qquickmousearea/tst_qquickmousearea.cpp b/tests/auto/quick/qquickmousearea/tst_qquickmousearea.cpp
index 91fcae40af..1c99357ab7 100644
--- a/tests/auto/quick/qquickmousearea/tst_qquickmousearea.cpp
+++ b/tests/auto/quick/qquickmousearea/tst_qquickmousearea.cpp
@@ -160,6 +160,7 @@ private slots:
     void mask();
     void nestedEventDelivery();
     void settingHiddenInPressUngrabs();
+    void containsMouseAndVisibility();
 
 private:
     int startDragDistance() const {
@@ -2450,6 +2451,55 @@ void tst_QQuickMouseArea::settingHiddenInPressUngrabs()
     QVERIFY(!mouseArea->pressed());
 }
 
+// QTBUG-87197
+void tst_QQuickMouseArea::containsMouseAndVisibility()
+{
+    QQuickView window;
+    QByteArray errorMessage;
+    QVERIFY2(QQuickTest::initView(window, testFileUrl("containsMouse.qml"), true, &errorMessage), errorMessage.constData());
+    window.show();
+    window.requestActivate();
+    QVERIFY(QTest::qWaitForWindowExposed(&window));
+
+    QQuickMouseArea *mouseArea = window.rootObject()->findChild<QQuickMouseArea*>("mouseArea");
+    QVERIFY(mouseArea != nullptr);
+    QVERIFY(!mouseArea->isVisible());
+
+    QTest::mouseMove(&window, QPoint(10, 10));
+    QTRY_VERIFY(!mouseArea->hovered());
+
+    mouseArea->setVisible(true);
+    QVERIFY(mouseArea->isVisible());
+    QTRY_VERIFY(mouseArea->hovered());
+
+    /* we (ab-)use QPointF() as the 'reset' value in QQuickWindow's leave-event handling,
+       but can't verify that this leaves an invalid interpretation of states for position
+       QPoint(0, 0) as QTest::mouseMove interprets a null-position as "center of the window".
+
+       So instead, verify the current (unexpectedly expected) behavior as far as testing is
+       concern.
+    */
+    QTest::mouseMove(&window, QPoint(0, 0));
+    QTRY_VERIFY(mouseArea->hovered());
+    QTRY_VERIFY(mouseArea->isUnderMouse());
+
+    // move to the edge (can't move outside)
+    QTest::mouseMove(&window, QPoint(window.width() - 1, window.height() / 2));
+    // then pretend we left
+    QEvent event(QEvent::Leave);
+    QGuiApplication::sendEvent(&window, &event);
+    QVERIFY(!mouseArea->hovered());
+
+    // toggle mouse area visibility - the hover state should not change
+    mouseArea->setVisible(false);
+    QVERIFY(!mouseArea->isVisible());
+    QVERIFY(!mouseArea->hovered());
+
+    mouseArea->setVisible(true);
+    QVERIFY(mouseArea->isVisible());
+    QVERIFY(!mouseArea->hovered());
+}
+
 QTEST_MAIN(tst_QQuickMouseArea)
 
 #include "tst_qquickmousearea.moc"
diff --git a/tests/auto/quick/qquickshortcut/tst_qquickshortcut.cpp b/tests/auto/quick/qquickshortcut/tst_qquickshortcut.cpp
index 4962690796..1985f3aa31 100644
--- a/tests/auto/quick/qquickshortcut/tst_qquickshortcut.cpp
+++ b/tests/auto/quick/qquickshortcut/tst_qquickshortcut.cpp
@@ -42,12 +42,16 @@ class tst_QQuickShortcut : public QQmlDataTest
     Q_OBJECT
 
 private slots:
+    void standardShortcuts_data();
+    void standardShortcuts();
     void shortcuts_data();
     void shortcuts();
     void sequence_data();
     void sequence();
     void context_data();
     void context();
+    void contextChange_data();
+    void contextChange();
     void matcher_data();
     void matcher();
     void multiple_data();
@@ -79,6 +83,49 @@ static QVariant shortcutMap(const QVariant &key, bool enabled = true, bool autoR
     return shortcutMap(key, Qt::WindowShortcut, enabled, autoRepeat);
 }
 
+void tst_QQuickShortcut::standardShortcuts_data()
+{
+    QTest::addColumn<QKeySequence::StandardKey>("standardKey");
+    QTest::newRow("Close") << QKeySequence::Close;
+    QTest::newRow("Cut") << QKeySequence::Cut;
+    QTest::newRow("NextChild") << QKeySequence::NextChild;
+    QTest::newRow("PreviousChild") << QKeySequence::PreviousChild;
+    QTest::newRow("FindNext") << QKeySequence::FindNext;
+    QTest::newRow("FindPrevious") << QKeySequence::FindPrevious;
+    QTest::newRow("FullScreen") << QKeySequence::FullScreen;
+}
+
+void tst_QQuickShortcut::standardShortcuts()
+{
+    QFETCH(QKeySequence::StandardKey, standardKey);
+
+    QQmlApplicationEngine engine;
+
+    engine.load(testFileUrl("multiple.qml"));
+    QQuickWindow *window = qobject_cast<QQuickWindow *>(engine.rootObjects().value(0));
+    QVERIFY(window);
+    window->show();
+    QVERIFY(QTest::qWaitForWindowExposed(window));
+    window->requestActivate();
+    QVERIFY(QTest::qWaitForWindowActive(window));
+
+    QObject *shortcut = window->property("shortcut").value<QObject *>();
+    QVERIFY(shortcut);
+
+    // create list of shortcuts
+    QVariantList shortcuts;
+    shortcuts.push_back(standardKey);
+    shortcut->setProperty("sequences", shortcuts);
+
+    // test all:
+    QList<QKeySequence> allsequences = QKeySequence::keyBindings(standardKey);
+    for (const QKeySequence &s : allsequences) {
+        window->setProperty("activated", false);
+        QTest::keySequence(window, s);
+        QCOMPARE(window->property("activated").toBool(), true);
+    }
+}
+
 void tst_QQuickShortcut::shortcuts_data()
 {
     QTest::addColumn<QVariantList>("shortcuts");
@@ -186,6 +233,7 @@ void tst_QQuickShortcut::shortcuts()
     window->setProperty("shortcuts", shortcuts);
 
     QTest::keyPress(window, key, modifiers);
+    QTest::keyRelease(window, key, modifiers);
     QCOMPARE(window->property("activatedShortcut").toString(), activatedShortcut);
     QCOMPARE(window->property("ambiguousShortcut").toString(), ambiguousShortcut);
 }
@@ -261,14 +309,22 @@ void tst_QQuickShortcut::sequence()
 
     window->setProperty("shortcuts", shortcuts);
 
-    if (key1 != 0)
+    if (key1 != 0) {
         QTest::keyPress(window, key1, modifiers1);
-    if (key2 != 0)
+        QTest::keyRelease(window, key1, modifiers1);
+    }
+    if (key2 != 0) {
         QTest::keyPress(window, key2, modifiers2);
-    if (key3 != 0)
+        QTest::keyRelease(window, key2, modifiers2);
+    }
+    if (key3 != 0) {
         QTest::keyPress(window, key3, modifiers3);
-    if (key4 != 0)
+        QTest::keyRelease(window, key3, modifiers3);
+    }
+    if (key4 != 0) {
         QTest::keyPress(window, key4, modifiers4);
+        QTest::keyRelease(window, key4, modifiers4);
+    }
 
     QCOMPARE(window->property("activatedShortcut").toString(), activatedShortcut);
     QCOMPARE(window->property("ambiguousShortcut").toString(), ambiguousShortcut);
@@ -350,6 +406,7 @@ void tst_QQuickShortcut::context()
     activeWindow->setProperty("shortcuts", activeWindowShortcuts);
 
     QTest::keyPress(activeWindow, key);
+    QTest::keyRelease(activeWindow, key);
 
     QCOMPARE(activeWindow->property("activatedShortcut").toString(), activeWindowActivatedShortcut);
     QCOMPARE(inactiveWindow->property("activatedShortcut").toString(), inactiveWindowActivatedShortcut);
@@ -409,6 +466,8 @@ void tst_QQuickShortcut::matcher()
     QVERIFY(window);
     window->show();
     QVERIFY(QTest::qWaitForWindowExposed(window));
+    window->requestActivate();
+    QVERIFY(QTest::qWaitForWindowActive(window));
 
     window->setProperty("shortcuts", QVariantList() << shortcut);
     QTest::keyClick(window, key);
@@ -450,6 +509,8 @@ void tst_QQuickShortcut::multiple()
     QVERIFY(window);
     window->show();
     QVERIFY(QTest::qWaitForWindowExposed(window));
+    window->requestActivate();
+    QVERIFY(QTest::qWaitForWindowActive(window));
 
     QObject *shortcut = window->property("shortcut").value<QObject *>();
     QVERIFY(shortcut);
@@ -458,8 +519,75 @@ void tst_QQuickShortcut::multiple()
     shortcut->setProperty("sequences", sequences);
 
     QTest::keyPress(window, key, modifiers);
+    QTest::keyRelease(window, key, modifiers);
+
+    QCOMPARE(window->property("activated").toBool(), activated);
+
+    // check it still works after rotating the sequences
+    QStringList rotatedSequences;
+    for (int i = 1; i < sequences.size(); ++i)
+        rotatedSequences.push_back(sequences[i]);
+    if (sequences.size())
+        rotatedSequences.push_back(sequences[0]);
+
+    window->setProperty("activated", false);
+    shortcut->setProperty("sequences", rotatedSequences);
 
+    QTest::keyPress(window, key, modifiers);
+    QTest::keyRelease(window, key, modifiers);
     QCOMPARE(window->property("activated").toBool(), activated);
+
+    // check setting to no shortcuts
+    QStringList emptySequence;
+
+    window->setProperty("activated", false);
+    shortcut->setProperty("sequences", emptySequence);
+
+    QTest::keyPress(window, key, modifiers);
+    QTest::keyRelease(window, key, modifiers);
+    QCOMPARE(window->property("activated").toBool(), false);
+}
+
+void tst_QQuickShortcut::contextChange_data()
+{
+    multiple_data();
+}
+void tst_QQuickShortcut::contextChange()
+{
+    QFETCH(QStringList, sequences);
+    QFETCH(Qt::Key, key);
+    QFETCH(Qt::KeyboardModifiers, modifiers);
+    QFETCH(bool, enabled);
+    QFETCH(bool, activated);
+
+    QQmlApplicationEngine engine;
+
+    engine.load(testFileUrl("multiple.qml"));
+    QQuickWindow *inactivewindow = qobject_cast<QQuickWindow *>(engine.rootObjects().value(0));
+    QVERIFY(inactivewindow);
+    inactivewindow->show();
+    QVERIFY(QTest::qWaitForWindowExposed(inactivewindow));
+
+    QObject *shortcut = inactivewindow->property("shortcut").value<QObject *>();
+    QVERIFY(shortcut);
+
+    shortcut->setProperty("enabled", enabled);
+    shortcut->setProperty("sequences", sequences);
+    shortcut->setProperty("context", Qt::WindowShortcut);
+
+    engine.load(testFileUrl("multiple.qml"));
+    QQuickWindow *activewindow = qobject_cast<QQuickWindow *>(engine.rootObjects().value(1));
+    QVERIFY(activewindow);
+    activewindow->show();
+    QVERIFY(QTest::qWaitForWindowExposed(activewindow));
+
+    QTest::keyPress(activewindow, key, modifiers);
+    QCOMPARE(inactivewindow->property("activated").toBool(), false);
+
+    shortcut->setProperty("context", Qt::ApplicationShortcut);
+
+    QTest::keyPress(activewindow, key, modifiers);
+    QCOMPARE(inactivewindow->property("activated").toBool(), activated);
 }
 
 #ifdef QT_QUICKWIDGETS_LIB
@@ -572,6 +700,7 @@ void tst_QQuickShortcut::renderControlShortcuts()
     QQuickItem* item = quickWidget->rootObject();
     item->setProperty("shortcuts", shortcuts);
     QTest::keyPress(quickWidget->quickWindow(), key, modifiers, 1500);
+    QTest::keyRelease(quickWidget->quickWindow(), key, modifiers, 1600);
     QCOMPARE(item->property("activatedShortcut").toString(), activatedShortcut);
     QCOMPARE(item->property("ambiguousShortcut").toString(), ambiguousShortcut);
 }
diff --git a/tests/auto/quick/qquickstates/data/revertNullObjectBinding.qml b/tests/auto/quick/qquickstates/data/revertNullObjectBinding.qml
new file mode 100644
index 0000000000..dee82f52ed
--- /dev/null
+++ b/tests/auto/quick/qquickstates/data/revertNullObjectBinding.qml
@@ -0,0 +1,48 @@
+import QtQuick 2.12
+import Qt.test 1.0
+
+Item {
+    id: root
+    readonly property int someProp: 1234
+
+    property bool state1Active: false
+    property bool state2Active: false
+    StateGroup {
+        states: [
+            State {
+                id: state1
+                name: "state1"
+                when: state1Active
+                changes: [
+                    PropertyChanges {
+                        objectName: "propertyChanges1"
+                        target: ContainingObj.obj
+                        prop: root.someProp
+                    }
+                ]
+            }
+    ]}
+    StateGroup {
+        states: [
+            State {
+                id: state2
+                name: "state2"
+                when: state2Active
+                changes: [
+                    PropertyChanges {
+                        objectName: "propertyChanges2"
+                        target: ContainingObj.obj
+                        prop: 11111
+                    }
+                ]
+            }
+        ]
+    }
+
+    Component.onCompleted: {
+        state1Active = true;
+        state2Active = true;
+
+        ContainingObj.reset()
+    }
+}
diff --git a/tests/auto/quick/qquickstates/tst_qquickstates.cpp b/tests/auto/quick/qquickstates/tst_qquickstates.cpp
index d5fea3cb28..849522454f 100644
--- a/tests/auto/quick/qquickstates/tst_qquickstates.cpp
+++ b/tests/auto/quick/qquickstates/tst_qquickstates.cpp
@@ -79,6 +79,55 @@ private:
 QML_DECLARE_TYPE(MyRect)
 QML_DECLARE_TYPEINFO(MyRect, QML_HAS_ATTACHED_PROPERTIES)
 
+class RemovableObj : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(int prop READ prop WRITE setProp NOTIFY propChanged)
+
+public:
+    RemovableObj(QObject *parent) : QObject(parent), m_prop(4321) { }
+    int prop() const { return m_prop; }
+
+public slots:
+    void setProp(int prop)
+    {
+        if (m_prop == prop)
+            return;
+
+        m_prop = prop;
+        emit propChanged(m_prop);
+    }
+
+signals:
+    void propChanged(int prop);
+
+private:
+    int m_prop;
+};
+
+class ContainingObj : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(RemovableObj *obj READ obj NOTIFY objChanged)
+    RemovableObj *m_obj;
+
+public:
+    ContainingObj() : m_obj(new RemovableObj(this)) { }
+    RemovableObj *obj() const { return m_obj; }
+
+    Q_INVOKABLE void reset()
+    {
+        if (m_obj) {
+            m_obj->deleteLater();
+        }
+
+        m_obj = new RemovableObj(this);
+        emit objChanged();
+    }
+signals:
+    void objChanged();
+};
+
 class tst_qquickstates : public QQmlDataTest
 {
     Q_OBJECT
@@ -140,12 +189,20 @@ private slots:
     void duplicateStateName();
     void trivialWhen();
     void parentChangeCorrectReversal();
+    void revertNullObjectBinding();
 };
 
 void tst_qquickstates::initTestCase()
 {
     QQmlDataTest::initTestCase();
     qmlRegisterType<MyRect>("Qt.test", 1, 0, "MyRectangle");
+    qmlRegisterSingletonType<ContainingObj>(
+            "Qt.test", 1, 0, "ContainingObj", [](QQmlEngine *engine, QJSEngine *) {
+                static ContainingObj instance;
+                engine->setObjectOwnership(&instance, QQmlEngine::CppOwnership);
+                return &instance;
+            });
+    qmlRegisterUncreatableType<RemovableObj>("Qt.test", 1, 0, "RemovableObj", "Uncreatable");
 }
 
 QByteArray tst_qquickstates::fullDataPath(const QString &path) const
@@ -1692,6 +1749,17 @@ void tst_qquickstates::parentChangeCorrectReversal()
     QCOMPARE(oldX, stayingRectX.read().toDouble());
 }
 
+void tst_qquickstates::revertNullObjectBinding()
+{
+    QQmlEngine engine;
+
+    QQmlComponent c(&engine, testFileUrl("revertNullObjectBinding.qml"));
+    QScopedPointer<QObject> root { c.create() };
+    QVERIFY(root);
+    QTest::qWait(10);
+    QQmlProperty state2Active(root.get(), "state2Active");
+    state2Active.write(false);
+}
 
 QTEST_MAIN(tst_qquickstates)
 
diff --git a/tests/auto/quick/qquicktableview/data/sizefromdelegate.qml b/tests/auto/quick/qquicktableview/data/sizefromdelegate.qml
new file mode 100644
index 0000000000..b4a04c89cb
--- /dev/null
+++ b/tests/auto/quick/qquicktableview/data/sizefromdelegate.qml
@@ -0,0 +1,74 @@
+/****************************************************************************
+**
+** Copyright (C) 2021 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtQuick module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+import QtQuick 2.12
+import QtQuick.Window 2.3
+
+Item {
+    width: 640
+    height: 450
+
+    property alias tableView: tableView
+
+    TableView {
+        id: tableView
+        width: 600
+        height: 400
+        anchors.margins: 1
+        delegate: tableViewDelegate
+        columnSpacing: 1
+        rowSpacing: 1
+    }
+
+    Component {
+        id: tableViewDelegate
+        Rectangle {
+            color: "lightgray"
+            implicitWidth: text.width
+            implicitHeight: text.height
+
+            Text {
+                id: text
+                anchors.centerIn: parent
+                text: modelData
+            }
+        }
+    }
+
+}
diff --git a/tests/auto/quick/qquicktableview/tst_qquicktableview.cpp b/tests/auto/quick/qquicktableview/tst_qquicktableview.cpp
index 54f73c6e0c..d14c37d8e3 100644
--- a/tests/auto/quick/qquicktableview/tst_qquicktableview.cpp
+++ b/tests/auto/quick/qquicktableview/tst_qquicktableview.cpp
@@ -121,7 +121,9 @@ private slots:
     void checkForceLayoutFunction();
     void checkForceLayoutEndUpDoingALayout();
     void checkForceLayoutDuringModelChange();
+    void checkForceLayoutWhenAllItemsAreHidden();
     void checkContentWidthAndHeight();
+    void checkContentWidthAndHeightForSmallTables();
     void checkPageFlicking();
     void checkExplicitContentWidthAndHeight();
     void checkExtents_origin();
@@ -176,6 +178,7 @@ private slots:
     void checkSyncView_connect_late_data();
     void checkSyncView_connect_late();
     void checkSyncView_pageFlicking();
+    void checkSyncView_emptyModel();
     void delegateWithRequiredProperties();
     void checkThatFetchMoreIsCalledWhenScrolledToTheEndOfTable();
     void replaceModel();
@@ -624,6 +627,38 @@ void tst_QQuickTableView::checkForceLayoutDuringModelChange()
     QCOMPARE(tableView->rows(), initialRowCount + 1);
 }
 
+void tst_QQuickTableView::checkForceLayoutWhenAllItemsAreHidden()
+{
+    // Check that you can have a TableView where all columns are
+    // initially hidden, and then show some columns and call
+    // forceLayout(). This should make the columns become visible.
+    LOAD_TABLEVIEW("forcelayout.qml");
+
+    // Tell all columns to be hidden
+    const char *propertyName = "columnWidths";
+    view->rootObject()->setProperty(propertyName, 0);
+
+    const int rows = 3;
+    const int columns = 3;
+    auto model = TestModelAsVariant(rows, columns);
+    tableView->setModel(model);
+
+    WAIT_UNTIL_POLISHED;
+
+    // Check that the we have no items loaded
+    QCOMPARE(tableViewPrivate->loadedColumns.count(), 0);
+    QCOMPARE(tableViewPrivate->loadedRows.count(), 0);
+    QCOMPARE(tableViewPrivate->loadedItems.count(), 0);
+
+    // Tell all columns to be visible
+    view->rootObject()->setProperty(propertyName, 10);
+    tableView->forceLayout();
+
+    QCOMPARE(tableViewPrivate->loadedRows.count(), rows);
+    QCOMPARE(tableViewPrivate->loadedColumns.count(), columns);
+    QCOMPARE(tableViewPrivate->loadedItems.count(), rows * columns);
+}
+
 void tst_QQuickTableView::checkContentWidthAndHeight()
 {
     // Check that contentWidth/Height reports the correct size of the
@@ -672,6 +707,30 @@ void tst_QQuickTableView::checkContentWidthAndHeight()
     QCOMPARE(tableView->contentHeight(), expectedSizeInit);
 }
 
+void tst_QQuickTableView::checkContentWidthAndHeightForSmallTables()
+{
+    // For tables where all the columns in the model are loaded, we know
+    // the exact table width, and can therefore update the content width
+    // if e.g new rows are added or removed. The same is true for rows.
+    // This test will check that we do so.
+    LOAD_TABLEVIEW("sizefromdelegate.qml");
+
+    TestModel model(3, 3);
+    tableView->setModel(QVariant::fromValue(&model));
+    WAIT_UNTIL_POLISHED;
+
+    const qreal initialContentWidth = tableView->contentWidth();
+    const qreal initialContentHeight = tableView->contentHeight();
+    const QString longText = QStringLiteral("Adding a row with a very long text");
+    model.insertRow(0);
+    model.setModelData(QPoint(0, 0), QSize(1, 1), longText);
+
+    WAIT_UNTIL_POLISHED;
+
+    QVERIFY(tableView->contentWidth() > initialContentWidth);
+    QVERIFY(tableView->contentHeight() > initialContentHeight);
+}
+
 void tst_QQuickTableView::checkPageFlicking()
 {
     // Check that we rebuild the table instead of refilling edges, if the viewport moves
@@ -2731,6 +2790,48 @@ void tst_QQuickTableView::checkSyncView_pageFlicking()
     QVERIFY(tableViewPrivate->scheduledRebuildOptions & QQuickTableViewPrivate::RebuildOption::CalculateNewTopLeftRow);
 }
 
+void tst_QQuickTableView::checkSyncView_emptyModel()
+{
+    // When a tableview has a syncview with an empty model then it should still be
+    // showing the tableview without depending on the syncview. This is particularly
+    // important for headerviews for example
+    LOAD_TABLEVIEW("syncviewsimple.qml");
+    GET_QML_TABLEVIEW(tableViewH);
+    GET_QML_TABLEVIEW(tableViewV);
+    GET_QML_TABLEVIEW(tableViewHV);
+    QQuickTableView *views[] = {tableViewH, tableViewV, tableViewHV};
+
+    auto model = TestModelAsVariant(100, 100);
+
+    for (auto view : views)
+        view->setModel(model);
+
+    WAIT_UNTIL_POLISHED_ARG(tableViewHV);
+
+    // Check that geometry properties are mirrored
+    QCOMPARE(tableViewH->columnSpacing(), tableView->columnSpacing());
+    QCOMPARE(tableViewH->rowSpacing(), 0);
+    QCOMPARE(tableViewH->contentWidth(), tableView->contentWidth());
+    QVERIFY(tableViewH->contentHeight() > 0);
+    QCOMPARE(tableViewV->columnSpacing(), 0);
+    QCOMPARE(tableViewV->rowSpacing(), tableView->rowSpacing());
+    QCOMPARE(tableViewV->contentHeight(), tableView->contentHeight());
+    QVERIFY(tableViewV->contentWidth() > 0);
+
+    QCOMPARE(tableViewH->contentX(), tableView->contentX());
+    QCOMPARE(tableViewH->contentY(), 0);
+    QCOMPARE(tableViewV->contentX(), 0);
+    QCOMPARE(tableViewV->contentY(), tableView->contentY());
+    QCOMPARE(tableViewHV->contentX(), tableView->contentX());
+    QCOMPARE(tableViewHV->contentY(), tableView->contentY());
+
+    QCOMPARE(tableViewHPrivate->loadedTableOuterRect.left(), tableViewPrivate->loadedTableOuterRect.left());
+    QCOMPARE(tableViewHPrivate->loadedTableOuterRect.top(), 0);
+
+    QCOMPARE(tableViewVPrivate->loadedTableOuterRect.top(), tableViewPrivate->loadedTableOuterRect.top());
+    QCOMPARE(tableViewVPrivate->loadedTableOuterRect.left(), 0);
+}
+
 void tst_QQuickTableView::checkThatFetchMoreIsCalledWhenScrolledToTheEndOfTable()
 {
     LOAD_TABLEVIEW("plaintableview.qml");
diff --git a/tests/auto/quick/qquicktext/data/elideZeroWidth.qml b/tests/auto/quick/qquicktext/data/elideZeroWidth.qml
new file mode 100644
index 0000000000..1193909350
--- /dev/null
+++ b/tests/auto/quick/qquicktext/data/elideZeroWidth.qml
@@ -0,0 +1,23 @@
+import QtQuick 2.15
+
+Item {
+    id: root
+    property bool ok: false
+    width: 640
+    height: 480
+
+    Text {
+        id: text
+        text: "This is a quite long text. Click me and i should remain visible!!! Sadly this doesn't happen"
+        elide: Text.ElideRight
+    }
+
+    Component.onCompleted: {
+        text.width = 300;
+        text.height = 0;
+        text.width = 0;
+        text.height = 30;
+        text.width = 300;
+        root.ok = text.paintedWidth > 0 && text.paintedHeight > 0
+    }
+}
diff --git a/tests/auto/quick/qquicktext/tst_qquicktext.cpp b/tests/auto/quick/qquicktext/tst_qquicktext.cpp
index 42fdbea58d..fe3f696dfa 100644
--- a/tests/auto/quick/qquicktext/tst_qquicktext.cpp
+++ b/tests/auto/quick/qquicktext/tst_qquicktext.cpp
@@ -68,6 +68,7 @@ private slots:
     void wrap();
     void elide();
     void elideParentChanged();
+    void elideRelayoutAfterZeroWidth();
     void multilineElide_data();
     void multilineElide();
     void implicitElide_data();
@@ -607,6 +608,15 @@ void tst_qquicktext::elideParentChanged()
     QCOMPARE(actualItemImageGrab, expectedItemImageGrab);
 }
 
+void tst_qquicktext::elideRelayoutAfterZeroWidth()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine, testFileUrl("elideZeroWidth.qml"));
+    QScopedPointer<QObject> root(component.create());
+    QVERIFY2(root, qPrintable(component.errorString()));
+    QVERIFY(root->property("ok").toBool());
+}
+
 void tst_qquicktext::multilineElide_data()
 {
     QTest::addColumn<QQuickText::TextFormat>("format");
@@ -2243,6 +2253,43 @@ void tst_qquicktext::lineCount()
     QCOMPARE(myText->lineCount(), 2);
     QCOMPARE(myText->truncated(), true);
     QCOMPARE(myText->maximumLineCount(), 2);
+
+    // QTBUG-84458
+    myText->resetMaximumLineCount();
+    myText->setText("qqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 2);
+    myText->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 3);
+    myText->setText("");
+    QCOMPARE(myText->lineCount(), 1);
+
+    myText->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 3);
+    myText->setFontSizeMode(QQuickText::HorizontalFit);
+    myText->setText("");
+    QCOMPARE(myText->lineCount(), 1);
+
+    myText->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 3);
+    myText->setFontSizeMode(QQuickText::VerticalFit);
+    myText->setText("");
+    QCOMPARE(myText->lineCount(), 1);
+
+    myText->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(myText->lineCount(), 3);
+    myText->setFontSizeMode(QQuickText::Fit);
+    myText->setText("");
+    QCOMPARE(myText->lineCount(), 1);
+
+    QScopedPointer<QQuickView> layoutWindow(createView(testFile("lineLayoutHAlign.qml")));
+    QQuickText *lineLaidOut = layoutWindow->rootObject()->findChild<QQuickText*>("myText");
+    QVERIFY(lineLaidOut != nullptr);
+
+    lineLaidOut->setText("qqqqq\nqqqqq\nqqqqq");
+    QCOMPARE(lineLaidOut->lineCount(), 3);
+    lineLaidOut->setFontSizeMode(QQuickText::FixedSize);
+    lineLaidOut->setText("");
+    QCOMPARE(lineLaidOut->lineCount(), 1);
 }
 
 void tst_qquicktext::lineHeight()
diff --git a/tests/auto/quick/qquicktextinput/data/checkCursorDelegateWhenPaddingChanged.qml b/tests/auto/quick/qquicktextinput/data/checkCursorDelegateWhenPaddingChanged.qml
new file mode 100644
index 0000000000..e6f07b4687
--- /dev/null
+++ b/tests/auto/quick/qquicktextinput/data/checkCursorDelegateWhenPaddingChanged.qml
@@ -0,0 +1,16 @@
+import QtQuick 2.12
+
+Rectangle {
+    width: 200
+    height: 200
+    TextInput {
+        objectName: "textInput"
+        leftPadding: 10
+        focus: true
+        cursorDelegate: Rectangle {
+            objectName: "cursorDelegate"
+            width: 5
+            color: "red"
+        }
+    }
+}
diff --git a/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp b/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp
index 2e64c80b85..ac502bcb28 100644
--- a/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp
+++ b/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp
@@ -236,6 +236,7 @@ private slots:
     void QTBUG_51115_readOnlyResetsSelection();
     void QTBUG_77814_InsertRemoveNoSelection();
 
+    void checkCursorDelegateWhenPaddingChanged();
 private:
     void simulateKey(QWindow *, int key);
 
@@ -7054,6 +7055,35 @@ void tst_qquicktextinput::QTBUG_77814_InsertRemoveNoSelection()
     QCOMPARE(textInput->selectedText(), QString());
 }
 
+void tst_qquicktextinput::checkCursorDelegateWhenPaddingChanged()
+{
+    QQuickView view;
+    view.setSource(testFileUrl("checkCursorDelegateWhenPaddingChanged.qml"));
+    view.show();
+    QVERIFY(QTest::qWaitForWindowExposed(&view));
+
+    QQuickTextInput *textInput = view.rootObject()->findChild<QQuickTextInput *>("textInput");
+    QVERIFY(textInput);
+
+    QQuickItem *cursorDelegate = textInput->findChild<QQuickItem *>("cursorDelegate");
+    QVERIFY(cursorDelegate);
+
+    QCOMPARE(cursorDelegate->x(), textInput->leftPadding());
+    QCOMPARE(cursorDelegate->y(), textInput->topPadding());
+
+    textInput->setPadding(5);
+    QCOMPARE(cursorDelegate->x(), textInput->leftPadding());
+    QCOMPARE(cursorDelegate->y(), textInput->topPadding());
+
+    textInput->setTopPadding(10);
+    QCOMPARE(cursorDelegate->x(), textInput->leftPadding());
+    QCOMPARE(cursorDelegate->y(), textInput->topPadding());
+
+    textInput->setLeftPadding(10);
+    QCOMPARE(cursorDelegate->x(), textInput->leftPadding());
+    QCOMPARE(cursorDelegate->y(), textInput->topPadding());
+}
+
 QTEST_MAIN(tst_qquicktextinput)
 
 #include "tst_qquicktextinput.moc"
diff --git a/tests/auto/quick/qquickview_extra/data/qtbug_87228.qml b/tests/auto/quick/qquickview_extra/data/qtbug_87228.qml
new file mode 100644
index 0000000000..ff10eba23d
--- /dev/null
+++ b/tests/auto/quick/qquickview_extra/data/qtbug_87228.qml
@@ -0,0 +1,30 @@
+import QtQml 2.12
+import QtQml.Models 2.12
+import QtQuick 2.12
+
+Item {
+    height: 480
+    width: 320
+    Rectangle {
+        id: rootRect
+
+        function addItem(desc) {
+            myModel.append({"desc": desc});
+        }
+
+        Rectangle {
+            ListView {
+                objectName: "listView"
+                delegate: Text {
+                    required property string desc
+                    text: desc
+                }
+                model: ListModel { id: myModel }
+            }
+        }
+
+        Component.onCompleted: {
+            addItem("Test creation of a delegate with a property");
+        }
+    }
+}
diff --git a/tests/auto/quick/qquickview_extra/qquickview_extra.pro b/tests/auto/quick/qquickview_extra/qquickview_extra.pro
new file mode 100644
index 0000000000..b40af0ce19
--- /dev/null
+++ b/tests/auto/quick/qquickview_extra/qquickview_extra.pro
@@ -0,0 +1,12 @@
+CONFIG += testcase
+TARGET = tst_qquickview_extra
+macx:CONFIG -= app_bundle
+
+SOURCES += tst_qquickview_extra.cpp
+
+include (../../shared/util.pri)
+include (../shared/util.pri)
+
+TESTDATA = data/*
+
+QT += core-private gui-private qml-private quick-private testlib
diff --git a/tests/auto/quick/qquickview_extra/tst_qquickview_extra.cpp b/tests/auto/quick/qquickview_extra/tst_qquickview_extra.cpp
new file mode 100644
index 0000000000..f697a438bd
--- /dev/null
+++ b/tests/auto/quick/qquickview_extra/tst_qquickview_extra.cpp
@@ -0,0 +1,77 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <qtest.h>
+#include <QtTest/QSignalSpy>
+#include <QtQuick/qquickview.h>
+#include <QtQuick/qquickitem.h>
+#include <QtQml/qqmlengine.h>
+#include "../../shared/util.h"
+#include <QtCore/QDebug>
+#include <QtCore/QTimer>
+
+// Extra app-less tests
+class tst_QQuickViewExtra : public QQmlDataTest
+{
+    Q_OBJECT
+public:
+    tst_QQuickViewExtra();
+
+private slots:
+    void qtbug_87228();
+};
+
+tst_QQuickViewExtra::tst_QQuickViewExtra() { }
+
+void tst_QQuickViewExtra::qtbug_87228()
+{
+    QScopedPointer<QSignalSpy> deletionSpy;
+    {
+        int argc = 0;
+        QGuiApplication app(argc, nullptr);
+        QQuickView view;
+
+        view.setSource(testFileUrl("qtbug_87228.qml"));
+        view.show();
+        QTimer::singleShot(500, &app, QCoreApplication::quit);
+        app.exec();
+
+        QObject *listView = view.findChild<QObject *>("listView");
+        QVERIFY(listView);
+        QQuickItem *contentItem = listView->property("contentItem").value<QQuickItem *>();
+        QVERIFY(contentItem);
+        auto children = contentItem->childItems();
+        QVERIFY(children.size() > 0);
+        // for the sake of this test, any child would be suitable, so pick first
+        deletionSpy.reset(new QSignalSpy(children[0], SIGNAL(destroyed(QObject *))));
+    }
+    QCOMPARE(deletionSpy->count(), 1);
+}
+
+QTEST_APPLESS_MAIN(tst_QQuickViewExtra)
+
+#include "tst_qquickview_extra.moc"
diff --git a/tests/auto/quick/quick.pro b/tests/auto/quick/quick.pro
index 541bfdd527..45bcf8a9ce 100644
--- a/tests/auto/quick/quick.pro
+++ b/tests/auto/quick/quick.pro
@@ -85,6 +85,7 @@ QUICKTESTS += \
     qquicktextinput \
     qquickvisualdatamodel \
     qquickview \
+    qquickview_extra \
     qquickcanvasitem \
     qquickdesignersupport \
     qquickscreen \
diff --git a/tests/auto/quicktest/quicktest.pro b/tests/auto/quicktest/quicktest.pro
index 6d09f76c1d..2116e4d3ac 100644
--- a/tests/auto/quicktest/quicktest.pro
+++ b/tests/auto/quicktest/quicktest.pro
@@ -3,4 +3,5 @@ SUBDIRS = \
     polish \
     signalspy \
     quicktestmainwithsetup \
-    testfiltering
+    testfiltering \
+    testwithcomponents
diff --git a/tests/auto/quicktest/testwithcomponents/data/Sample.qml b/tests/auto/quicktest/testwithcomponents/data/Sample.qml
new file mode 100644
index 0000000000..78e3008b01
--- /dev/null
+++ b/tests/auto/quicktest/testwithcomponents/data/Sample.qml
@@ -0,0 +1,8 @@
+import QtQuick 2.15
+
+Item {
+    id: root
+
+    component InlineComponent: Rectangle {}
+    InlineComponent{}
+}
diff --git a/tests/auto/quicktest/testwithcomponents/data/tst_setup.qml b/tests/auto/quicktest/testwithcomponents/data/tst_setup.qml
new file mode 100644
index 0000000000..533027147e
--- /dev/null
+++ b/tests/auto/quicktest/testwithcomponents/data/tst_setup.qml
@@ -0,0 +1,53 @@
+/****************************************************************************
+**
+** Copyright (C) 2021 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+import QtQuick 2.0
+import QtTest 1.2
+
+
+Item {
+
+    Component {
+        id: mock
+        Sample {
+        }
+    }
+
+    component Mock : Sample {}
+
+    TestCase {
+        id: root
+        name: "ComponentTest"
+
+        function test_create()
+        {
+            let dialog = createTemporaryObject(mock, root);
+            verify(dialog);
+        }
+    }
+}
diff --git a/tests/auto/quicktest/testwithcomponents/testwithcomponents.pro b/tests/auto/quicktest/testwithcomponents/testwithcomponents.pro
new file mode 100644
index 0000000000..8f64dc2ebb
--- /dev/null
+++ b/tests/auto/quicktest/testwithcomponents/testwithcomponents.pro
@@ -0,0 +1,10 @@
+CONFIG += qmltestcase
+macos:CONFIG -= app_bundle
+TARGET = tst_quicktestwithcomponents
+
+QT += testlib quick
+
+SOURCES += tst_quicktestwithcomponents.cpp
+
+TESTDATA += \
+    $$PWD/data/*.qml
diff --git a/tests/auto/quicktest/testwithcomponents/tst_quicktestwithcomponents.cpp b/tests/auto/quicktest/testwithcomponents/tst_quicktestwithcomponents.cpp
new file mode 100644
index 0000000000..9692347cb8
--- /dev/null
+++ b/tests/auto/quicktest/testwithcomponents/tst_quicktestwithcomponents.cpp
@@ -0,0 +1,32 @@
+/****************************************************************************
+**
+** Copyright (C) 2021 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtTest/qtest.h>
+#include <QtQuickTest/quicktest.h>
+
+QUICK_TEST_MAIN(data)
diff --git a/tests/manual/scenegraph_lancelot/data/rotation/rotation_clip_multi.qml b/tests/manual/scenegraph_lancelot/data/rotation/rotation_clip_multi.qml
new file mode 100644
index 0000000000..277ac4f2db
--- /dev/null
+++ b/tests/manual/scenegraph_lancelot/data/rotation/rotation_clip_multi.qml
@@ -0,0 +1,38 @@
+import QtQuick 2.0
+
+Rectangle {
+    width: 320
+    height: 480
+    property int standardWidth: 60
+    property int standardHeight: 60
+    property int standardSpacing: 20
+    property bool smoothing: true
+    Rectangle {
+        width: 150
+        height: 150
+        anchors.centerIn: parent
+        color: "black"
+        clip: true
+        rotation: 45
+        Rectangle {
+            width: 200
+            height: 200
+            anchors.centerIn: parent
+            color: "lightGray"
+            clip: true
+            Grid {
+                anchors.centerIn: parent
+                columns: 4
+                spacing: standardSpacing
+                Rectangle{ color: "red"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: standardWidth/2; origin.y: standardHeight/2 ; axis{x: 0; y: 0; z:1} angle: 5; } smooth: smoothing}
+                Rectangle{ color: "orange"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 10; } smooth: smoothing }
+                Rectangle{ color: "yellow"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 15; } smooth: smoothing }
+                Rectangle{ color: "blue"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 20; } smooth: smoothing }
+                Rectangle{ color: "green"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: standardWidth/2; origin.y: standardWidth/2 ; axis{x: 0; y: 0; z:1} angle: 15; } smooth: smoothing}
+                Rectangle{ color: "indigo"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 30; } smooth: smoothing}
+                Rectangle{ color: "violet"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 35; } smooth: smoothing }
+                Rectangle{ color: "light green"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 40; } smooth: smoothing }
+            }
+        }
+    }
+}
diff --git a/tests/manual/scenegraph_lancelot/data/rotation/rotation_clip_scissor.qml b/tests/manual/scenegraph_lancelot/data/rotation/rotation_clip_scissor.qml
new file mode 100644
index 0000000000..71379ff1bb
--- /dev/null
+++ b/tests/manual/scenegraph_lancelot/data/rotation/rotation_clip_scissor.qml
@@ -0,0 +1,30 @@
+import QtQuick 2.0
+
+Rectangle {
+    width: 320
+    height: 480
+    property int standardWidth: 60
+    property int standardHeight: 60
+    property int standardSpacing: 20
+    property bool smoothing: true
+    Rectangle {
+        width: 200
+        height: 200
+        anchors.centerIn: parent
+        color: "lightGray"
+        clip: true
+        Grid {
+            anchors.centerIn: parent
+            columns: 4
+            spacing: standardSpacing
+            Rectangle{ color: "red"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: standardWidth/2; origin.y: standardHeight/2 ; axis{x: 0; y: 0; z:1} angle: 5; } smooth: smoothing}
+            Rectangle{ color: "orange"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 10; } smooth: smoothing }
+            Rectangle{ color: "yellow"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 15; } smooth: smoothing }
+            Rectangle{ color: "blue"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 20; } smooth: smoothing }
+            Rectangle{ color: "green"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: standardWidth/2; origin.y: standardWidth/2 ; axis{x: 0; y: 0; z:1} angle: 15; } smooth: smoothing}
+            Rectangle{ color: "indigo"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 30; } smooth: smoothing}
+            Rectangle{ color: "violet"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 35; } smooth: smoothing }
+            Rectangle{ color: "light green"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 40; } smooth: smoothing }
+        }
+    }
+}
diff --git a/tests/manual/scenegraph_lancelot/data/rotation/rotation_clip_stencil.qml b/tests/manual/scenegraph_lancelot/data/rotation/rotation_clip_stencil.qml
new file mode 100644
index 0000000000..f6167e70e0
--- /dev/null
+++ b/tests/manual/scenegraph_lancelot/data/rotation/rotation_clip_stencil.qml
@@ -0,0 +1,31 @@
+import QtQuick 2.0
+
+Rectangle {
+    width: 320
+    height: 480
+    property int standardWidth: 60
+    property int standardHeight: 60
+    property int standardSpacing: 20
+    property bool smoothing: true
+    Rectangle {
+        width: 200
+        height: 200
+        anchors.centerIn: parent
+        color: "lightGray"
+        rotation: 45
+        clip: true
+        Grid {
+            anchors.centerIn: parent
+            columns: 4
+            spacing: standardSpacing
+            Rectangle{ color: "red"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: standardWidth/2; origin.y: standardHeight/2 ; axis{x: 0; y: 0; z:1} angle: 5; } smooth: smoothing}
+            Rectangle{ color: "orange"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 10; } smooth: smoothing }
+            Rectangle{ color: "yellow"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 15; } smooth: smoothing }
+            Rectangle{ color: "blue"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 20; } smooth: smoothing }
+            Rectangle{ color: "green"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: standardWidth/2; origin.y: standardWidth/2 ; axis{x: 0; y: 0; z:1} angle: 15; } smooth: smoothing}
+            Rectangle{ color: "indigo"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 30; } smooth: smoothing}
+            Rectangle{ color: "violet"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 35; } smooth: smoothing }
+            Rectangle{ color: "light green"; width: standardWidth; height: standardHeight; transform: Rotation { origin.x: 0; origin.y: 0 ; axis{x: 0; y: 0; z:1} angle: 40; } smooth: smoothing }
+        }
+    }
+}
diff --git a/tests/manual/scenegraph_lancelot/data/text/text_nativerendering_subpixelpositions.qml b/tests/manual/scenegraph_lancelot/data/text/text_nativerendering_subpixelpositions.qml
new file mode 100644
index 0000000000..c60fc4d8b0
--- /dev/null
+++ b/tests/manual/scenegraph_lancelot/data/text/text_nativerendering_subpixelpositions.qml
@@ -0,0 +1,91 @@
+import QtQuick 2.0
+
+//vary font style, native rendering at non-integer offsets
+
+Item {
+    id: topLevel
+    width: 320
+    height: 580
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Text {
+            y: 20 * index
+            clip: true
+            renderType: Text.NativeRendering
+            width: parent.width
+            wrapMode: Text.Wrap
+            font.pointSize: 10
+            style: modelData
+            styleColor: "green"
+            text: "The quick fox jumps in style " + modelData
+        }
+    }
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Text {
+            y: 100.5 + 20 * index
+            clip: true
+            renderType: Text.NativeRendering
+            width: parent.width
+            wrapMode: Text.Wrap
+            font.pointSize: 10
+            style: modelData
+            styleColor: "green"
+            text: "The quick fox jumps in style " + modelData
+        }
+    }
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Text {
+            y: 200.5 + 20 * index
+            x: 0.5
+            clip: true
+            renderType: Text.NativeRendering
+            width: parent.width
+            wrapMode: Text.Wrap
+            font.pointSize: 10
+            style: modelData
+            styleColor: "green"
+            text: "The quick fox jumps in style " + modelData
+        }
+    }
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Text {
+            y: 300.5 + 20 * index
+            x: 0.5
+            clip: true
+            renderType: Text.NativeRendering
+            width: parent.width
+            wrapMode: Text.Wrap
+            font.pointSize: 10
+            style: modelData
+            styleColor: "green"
+            text: "The quick fox jumps in style " + modelData
+        }
+    }
+
+    Repeater {
+        model: [Text.Normal, Text.Outline, Text.Raised, Text.Sunken]
+        Rectangle {
+            y: 400.5 + 20 * index
+            x: 0.5
+            width: topLevel.width
+            height: topLevel.height
+            clip: true
+            Text {
+                renderType: Text.NativeRendering
+                width: parent.width
+                wrapMode: Text.Wrap
+                font.pointSize: 10
+                style: modelData
+                styleColor: "green"
+                text: "The quick fox jumps in style " + modelData
+            }
+        }
+    }
+}
diff --git a/tools/qmlplugindump/main.cpp b/tools/qmlplugindump/main.cpp
index 1556718471..b87b55283a 100644
--- a/tools/qmlplugindump/main.cpp
+++ b/tools/qmlplugindump/main.cpp
@@ -109,14 +109,16 @@ struct QmlVersionInfo
 };
 
 static bool matchingImportUri(const QQmlType &ty, const QmlVersionInfo& versionInfo) {
+    const QString &module = ty.module();
     if (versionInfo.strict) {
-        return (versionInfo.pluginImportUri == ty.module()
-                && (ty.majorVersion() == versionInfo.majorVersion || ty.majorVersion() == -1))
-                || ty.module().isEmpty();
+        return (versionInfo.pluginImportUri == module
+                && (ty.majorVersion() == versionInfo.majorVersion
+                    || ty.majorVersion() == -1))
+                || module.isEmpty();
     }
-    return ty.module().isEmpty()
-            || versionInfo.pluginImportUri == ty.module()
-            || ty.module().startsWith(versionInfo.pluginImportUri + QLatin1Char('.'));
+    return module.isEmpty()
+            || versionInfo.pluginImportUri == module
+            || module.startsWith(versionInfo.pluginImportUri + QLatin1Char('.'));
 }
 
 void collectReachableMetaObjects(const QMetaObject *meta, QSet<const QMetaObject *> *metas,  const QmlVersionInfo &info, bool extended = false, bool alreadyChangedModule = false)
diff --git a/tools/qmltime/qmltime.pro b/tools/qmltime/qmltime.pro
index c915f6e8c1..366d90f75b 100644
--- a/tools/qmltime/qmltime.pro
+++ b/tools/qmltime/qmltime.pro
@@ -1,4 +1,3 @@
-TEMPLATE = app
 TARGET = qmltime
 QT += qml quick
 QT += quick-private
@@ -12,3 +11,5 @@ QMAKE_TARGET_DESCRIPTION = QML Time
 
 SOURCES += qmltime.cpp
 HEADERS += qmltime.h
+
+load(qt_tool)
